# æ“ä½œï¼š

## ETXï¼š

 [https://newetx.eagle.local](http://newetx.eagle.local/etx/)



## odsä½ç½®ï¼š

```
/proj/EccadReleases/daily/main/æœ€æ–°æ—¶é—´/ods_xxx
ods	// æ‰“å¼€odså›¾å½¢ç•Œé¢
odst // æ‰“å¼€odså‘½ä»¤è¡Œç•Œé¢
```



## å…¶ä»–ï¼š

```
vivado
verdi
// modelsim_licè”åˆodsä»¿çœŸ(è¦å…ˆç¼–è¯‘ä»¿çœŸåº“æ–‡ä»¶)
modelsim_lic
ods
-----------//
```



## èŠ¯ç‰‡åç§°ï¼š

![image-20250916100920794](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250916100920794.png)



## åŸè¯­ä¾‹åŒ–æŸ¥çœ‹ï¼š

![image-20250926115821606](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250926115821606.png)



## tclå‘½ä»¤ä½¿ç”¨ï¼š

ç±»ä¼¼vivadoï¼Œä½¿ç”¨tclå‘½ä»¤å¯ä»¥è®©ODSè¿›è¡Œåˆ›å»ºå·¥ç¨‹ã€åŠ å…¥æ–‡ä»¶ã€é‡æ–°ç”ŸæˆIPã€è·‘flowç­‰æ“ä½œï¼Œåœ¨è¿›è¡Œæ‰¹é‡æ“ä½œçš„æ—¶å€™ï¼Œä½¿ç”¨tclå‘½ä»¤è‡ªåŠ¨è¿›è¡Œï¼Œå¯ä»¥èŠ‚çœå¤§é‡æ—¶é—´ç²¾åŠ›æˆæœ¬ã€‚

å¯ä»¥åœ¨å¯åŠ¨ ods çš„æ—¶å€™è‡ªåŠ¨æ‰§è¡Œ tcl è„šæœ¬ï¼š

```
sh /proj/EccadRealeases/daily/main/xxx/ods_xxx/ods_console.sh run.tcl
```



## å´©æºƒæ—¶æŸ¥çœ‹logæ–‡ä»¶ï¼š

æ²¡æœ‰errorå´©æºƒçš„è¯è¯´æ˜æ˜¯å†…å­˜ä¸å¤Ÿ

![image-20250916151148348](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250916151148348.png)

![image-20250916152358483](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250916152358483.png)

æ‰“å¼€.flowsæ–‡ä»¶å¤¹ï¼š

![image-20250916151205844](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250916151205844.png)

![image-20250916151220216](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250916151220216.png)

é‡Œé¢çš„**impl_1.logä»¥åŠsynth_1.logå°±æ˜¯æ—¥å¿—**

æˆ–è€…ç›´æ¥çœ‹è¾“å‡ºimpl_1æ–‡ä»¶å¤¹



## åˆ é™¤å ç”¨è¿›ç¨‹ï¼š

`ps` æ˜¯ Linux ä¸­æŸ¥çœ‹è¿›ç¨‹ä¿¡æ¯çš„å‘½ä»¤ï¼Œå…¨ç§° **process status**ã€‚

å¸¸ç”¨ç”¨æ³•ï¼š

-   `ps -u $USER`ï¼šæ˜¾ç¤ºå½“å‰ç”¨æˆ·çš„æ‰€æœ‰è¿›ç¨‹
-   `ps -ef`ï¼šæ˜¾ç¤ºç³»ç»Ÿä¸­æ‰€æœ‰è¿›ç¨‹ï¼ˆæ ‡å‡†æ ¼å¼ï¼‰
-   `ps aux`ï¼šå¦ä¸€ç§å¸¸ç”¨å…¨è¿›ç¨‹æ ¼å¼
-   `ps -u ç”¨æˆ·å`ï¼šæŸ¥çœ‹æŒ‡å®šç”¨æˆ·è¿›ç¨‹
-   `ps --sort=å­—æ®µ`ï¼šæŒ‰å­—æ®µæ’åºï¼Œå¦‚ `--sort=start_time`

å¸¸è§å­—æ®µå«ä¹‰ï¼š

-   `PID`ï¼šè¿›ç¨‹å·
-   `TTY`ï¼šç»ˆç«¯å
-   `TIME`ï¼šå ç”¨ CPU æ—¶é—´
-   `CMD`ï¼šæ‰§è¡Œçš„å‘½ä»¤
-   `STAT`ï¼šè¿›ç¨‹çŠ¶æ€ï¼ˆå¦‚ R è¿è¡Œï¼ŒS ç¡çœ ï¼ŒZ åƒµå°¸ï¼‰

ä¸»çŠ¶æ€å­—æ¯ï¼ˆå¿…æœ‰ä¸€ä¸ªï¼‰ï¼š

-   `R`ï¼šè¿è¡Œä¸­ï¼ˆRunningï¼‰
-   `S`ï¼šç¡çœ ä¸­ï¼ˆSleepingï¼Œå¯ä¸­æ–­ï¼‰
-   `D`ï¼šä¸å¯ä¸­æ–­ç¡çœ ï¼ˆé€šå¸¸åœ¨ç­‰å¾… I/Oï¼‰
-   `Z`ï¼šåƒµå°¸è¿›ç¨‹ï¼ˆZombieï¼‰
-   `T`ï¼šåœæ­¢/è¢«è¿½è¸ªï¼ˆStopped/Tracedï¼‰

é™„åŠ çŠ¶æ€ç¬¦å·ï¼ˆå¯æœ‰å¤šä¸ªï¼‰ï¼š

-   `s`ï¼šä¼šè¯é¦–è¿›ç¨‹ï¼ˆSession leaderï¼‰
-   `l`ï¼šå¤šçº¿ç¨‹è¿›ç¨‹ï¼ˆmultithreadedï¼‰
-   `+`ï¼šåœ¨å‰å°è¿›ç¨‹ç»„ï¼ˆforeground process groupï¼‰

æ‰€ä»¥ï¼š

-   `Ss+` â†’ ç¡çœ ä¸­ã€ä¼šè¯é¦–è¿›ç¨‹ã€å‰å°è¿›ç¨‹ç»„
-   `S+` â†’ ç¡çœ ä¸­ã€å‰å°è¿›ç¨‹ç»„
-   `Sl+` â†’ ç¡çœ ä¸­ã€å¤šçº¿ç¨‹ã€å‰å°è¿›ç¨‹ç»„
-   `R+` â†’ è¿è¡Œä¸­ã€å‰å°è¿›ç¨‹ç»„
-   `Rl+` â†’ è¿è¡Œä¸­ã€å¤šçº¿ç¨‹ã€å‰å°è¿›ç¨‹ç»„

å¯é…åˆ `grep`ã€`kill` ä¸€èµ·ä½¿ç”¨æ¥ç®¡ç†è¿›ç¨‹ã€‚

```shell
ps -u --sort=start_time
kill -9 xxx(PID)
```



## **Shellå‘½ä»¤ï¼š**

==Resource locked åˆ é™¤==

 â€œresource busy or lockedâ€ é”™è¯¯ï¼Œä¸€èˆ¬æ˜¯å› ä¸ºæ“ä½œç³»ç»Ÿè®¤ä¸ºè¯¥æ–‡ä»¶æ­£åœ¨è¢« **æŸä¸ªç¨‹åºå ç”¨**ï¼Œæ‰€ä»¥æ— æ³•åˆ é™¤ã€‚è§£å†³æ–¹æ³•å¯ä»¥æŒ‰ä»¥ä¸‹æ­¥éª¤æ“ä½œï¼š

**Linux / macOS ç³»ç»Ÿ**

-   æŸ¥æ‰¾å ç”¨æ–‡ä»¶çš„è¿›ç¨‹ï¼š

    ```
    lsof filename
    ```

-   ç»ˆæ­¢å ç”¨è¿›ç¨‹ï¼š

```
kill -9 <PID>
```

`kill -9 <PID>` ä¸­çš„ `-9` æ˜¯ **ä¿¡å·ç¼–å·**ï¼Œè¡¨ç¤º **SIGKILL** ä¿¡å·ã€‚

è§£é‡Šå¦‚ä¸‹ï¼š

-   Linux/Unix ç³»ç»Ÿé‡Œï¼Œ`kill` å‘½ä»¤å‘é€ä¿¡å·ç»™è¿›ç¨‹ï¼Œæ§åˆ¶å®ƒçš„è¡Œä¸ºã€‚
-   å¸¸ç”¨ä¿¡å·ç¼–å·ï¼š
    -   `-15`ï¼ˆSIGTERMï¼‰ï¼šè¯·æ±‚è¿›ç¨‹**æ­£å¸¸é€€å‡º**ï¼Œè¿›ç¨‹å¯ä»¥æ•è·ä¿¡å·åšæ¸…ç†ã€‚
    -   `-9`ï¼ˆSIGKILLï¼‰ï¼š**å¼ºåˆ¶æ€æ‰è¿›ç¨‹**ï¼Œæ“ä½œç³»ç»Ÿç›´æ¥ç»ˆæ­¢å®ƒï¼Œè¿›ç¨‹æ— æ³•æ•è·æˆ–æ¸…ç†ã€‚

æ‰€ä»¥ `kill -9 <PID>` çš„ä½œç”¨å°±æ˜¯ **æ— æ¡ä»¶å¼ºåˆ¶ç»“æŸå ç”¨è¯¥æ–‡ä»¶çš„è¿›ç¨‹**ï¼Œä¿è¯æ–‡ä»¶ä¸å†è¢«é”å®šï¼Œä¾¿äºåˆ é™¤ã€‚

==Continue==

åœ¨ Bash è„šæœ¬é‡Œï¼Œ`continue` çš„ä½œç”¨æ˜¯**ç«‹å³è·³è¿‡å½“å‰å¾ªç¯è¿­ä»£ï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªè¿­ä»£**ã€‚

ä¸¾ä¾‹ï¼š

```
for prj_dir in /home/pydu/Desktop/drc_test/*/; do
    prj_name=$(basename "$prj_dir")

    if grep -q "^$prj_name$" "$RUN_LOG"; then
        echo "Skipping $prj_name, already run"
        continue
    fi

    echo "Cleaning project $prj_name"
    # æ¸…ç†æ“ä½œ...
done
```

è§£é‡Šï¼š

1.  `for` å¾ªç¯éå†æ¯ä¸ªé¡¹ç›®ç›®å½•
2.  `grep` åˆ¤æ–­é¡¹ç›®åæ˜¯å¦å·²åœ¨ `RUN_LOG`
3.  å¦‚æœå·²ç»å­˜åœ¨ï¼Œæ‰§è¡Œ `continue`
    -   Bash ä¼š**è·³è¿‡å½“å‰å¾ªç¯ä½“å‰©ä¸‹çš„å†…å®¹**ï¼ˆè¿™é‡Œæ˜¯æ¸…ç†å’Œæ‰§è¡Œ tcl çš„æ­¥éª¤ï¼‰
    -   ç›´æ¥å¼€å§‹ä¸‹ä¸€ä¸ª `prj_dir` çš„å¾ªç¯
4.  å¦‚æœæ²¡åœ¨æ—¥å¿—é‡Œï¼Œ`continue` ä¸æ‰§è¡Œï¼Œåç»­æ¸…ç†å’Œæ‰§è¡Œæ“ä½œå°±ä¼šè¿›è¡Œ

æ‰€ä»¥ `continue` ä¿è¯äº†**å·²è·‘è¿‡çš„é¡¹ç›®ä¸ä¼šè¢«æ¸…ç†å’Œå†æ¬¡æ‰§è¡Œ**ã€‚

==æ–‡ä»¶å†™==

-   `>`ï¼šé‡å®šå‘ **è¦†ç›–å†™**ï¼Œæ„æ€æ˜¯â€œæ–°å»ºæ–‡ä»¶æˆ–æ¸…ç©ºå·²æœ‰æ–‡ä»¶å†å†™å…¥â€ã€‚

    ```
    echo "" > run.tcl
    ```

    è¿™ä¸€æ­¥æ˜¯ä¸ºäº†**ç¬¬ä¸€æ¬¡åˆ›å»º `run.tcl` æ–‡ä»¶**ï¼ˆå¦‚æœå·²ç»å­˜åœ¨ï¼Œå°±æ¸…ç©ºï¼‰ï¼Œä¿è¯è„šæœ¬ä»é›¶å¼€å§‹ã€‚

-   `>>`ï¼šé‡å®šå‘ **è¿½åŠ å†™**ï¼Œæ„æ€æ˜¯â€œåœ¨æ–‡ä»¶æœ«å°¾è¿½åŠ å†…å®¹â€ã€‚

    ```
    echo "set_property ..." >> run.tcl
    ```

    åç»­å°±æŠŠå‘½ä»¤ä¸€è¡Œä¸€è¡ŒåŠ åˆ° `run.tcl` é‡Œï¼Œè€Œä¸ä¼šè¦†ç›–ä¹‹å‰å†™è¿›å»çš„å†…å®¹ã€‚

æ‰€ä»¥æµç¨‹æ˜¯ï¼š

1.  ç¬¬ä¸€æ¬¡ç”¨ `>` â€”â€” æ¸…ç©º/æ–°å»ºè„šæœ¬æ–‡ä»¶ï¼›
2.  åé¢ç”¨ `>>` â€”â€” é€è¡ŒæŠŠå‘½ä»¤è¿½åŠ è¿›å»ï¼Œå½¢æˆå®Œæ•´çš„ Tcl è„šæœ¬ã€‚

==å¼•å·ä½œç”¨==

è·Ÿ **shell å˜é‡å±•å¼€** å’Œ **å¼•å·è§„åˆ™** æœ‰å…³ï¼š

å‡è®¾å‰é¢å®šä¹‰äº†ï¼š

```
ods_tcl="$run.tcl"
```

1.  **æ²¡å¼•å·çš„æƒ…å†µ**

    ```
    echo hello > $ods_tcl
    ```

    å¦‚æœ `$ods_tcl` å±•å¼€åæ˜¯ `my run.tcl`ï¼ˆå¸¦ç©ºæ ¼ï¼‰ï¼Œshell ä¼šæŠŠå®ƒå½“æˆ **ä¸¤ä¸ªå‚æ•°**ï¼Œç»“æœå°±ä¼šæŠ¥é”™ã€‚

2.  **æœ‰å¼•å·çš„æƒ…å†µ**

    ```
    echo hello > "$ods_tcl"
    ```

    å¼•å·ä¼šå‘Šè¯‰ shellï¼š**æŠŠæ•´ä¸ªå˜é‡å½“ä½œä¸€ä¸ªæ•´ä½“**ï¼Œå³ä½¿é‡Œé¢æœ‰ç©ºæ ¼æˆ–ç‰¹æ®Šå­—ç¬¦ï¼Œä¹Ÿåªå½“ä½œä¸€ä¸ªæ–‡ä»¶åã€‚

æ‰€ä»¥å“ªæ€•ä½ å®šä¹‰æˆ `"$run.tcl"`ï¼Œè°ƒç”¨æ—¶è¿˜æ˜¯è¦å†™ `"$ods_tcl"`ï¼Œç¡®ä¿å±•å¼€åä¸ä¼šè¢« shell æ‹†å¼€ã€‚

==è·¯å¾„å˜é‡==

-   **å­˜ç›®å½•è·¯å¾„**ï¼šæœ€å¥½åœ¨æœ€ååŠ ä¸Š `/`ï¼Œè¿™æ ·æ‹¼æ¥æ–‡ä»¶æ—¶æ›´æ¸…æ™°ã€‚

    ```
    outdir="/home/user/build/"
    logfile="${outdir}run.log"   # -> /home/user/build/run.log
    ```

-   **å­˜æ–‡ä»¶è·¯å¾„**ï¼šæœ€åå°±ä¸è¦ `/`ã€‚

    ```
    logfile="/home/user/build/run.log"
    ```

å…¶å® shell ä¸å¼ºåˆ¶æœ€åè¦ä¸è¦ `/`ï¼Œä½†æ‹¼æ¥å­—ç¬¦ä¸²æ—¶å®¹æ˜“å‡º bugï¼š

```
outdir="/home/user/build"
logfile="${outdir}/run.log"   # æ³¨æ„è¦è‡ªå·±è¡¥ /
```

ğŸ‘‰ ä¸€èˆ¬çº¦å®šï¼š

-   å˜é‡è¡¨ç¤ºç›®å½• â†’ ä¹ æƒ¯æ€§å¸¦ `/`ï¼›
-   å˜é‡è¡¨ç¤ºæ–‡ä»¶ â†’ ä¸å¸¦ `/`ã€‚



## Shellè„šæœ¬ï¼š

```
BASE_DIR=$(dirname "$(readlink -f "$0")")
```

é€å±‚è§£é‡Šï¼š

-   `$0`ï¼šå½“å‰è„šæœ¬çš„è·¯å¾„ï¼ˆå¯èƒ½æ˜¯ç›¸å¯¹è·¯å¾„ï¼‰ã€‚
-   `readlink -f "$0"`ï¼šæŠŠè„šæœ¬è·¯å¾„è½¬æˆ**ç»å¯¹è·¯å¾„**ï¼Œå¹¶è§£æç¬¦å·é“¾æ¥ã€‚
-   `dirname ...`ï¼šå–å‡ºè·¯å¾„ä¸­çš„ç›®å½•éƒ¨åˆ†ã€‚
-   `$( ... )`ï¼šå‘½ä»¤æ›¿æ¢ï¼ŒæŠŠæ‰§è¡Œç»“æœèµ‹å€¼ç»™å˜é‡ã€‚

æ‰€ä»¥æœ€å `BASE_DIR` å°±æ˜¯ **å½“å‰è„šæœ¬æ‰€åœ¨ç›®å½•çš„ç»å¯¹è·¯å¾„**ã€‚

```
V_FILES=$(find "$BASE_DIR" -type f -name "*.v" | xargs)
```

é€å±‚è§£é‡Šï¼š

1.  `find "$BASE_DIR" -type f -name "*.v"`ï¼šåœ¨ `BASE_DIR` ç›®å½•åŠå…¶æ‰€æœ‰å­ç›®å½•ä¸­æŸ¥æ‰¾**æ–‡ä»¶ç±»å‹ï¼ˆ-type fï¼‰**ï¼Œåå­—åŒ¹é… `*.v` çš„æ–‡ä»¶ï¼Œè¾“å‡ºå®ƒä»¬çš„ç»å¯¹æˆ–ç›¸å¯¹è·¯å¾„ã€‚

    åœ¨ `find` å‘½ä»¤é‡Œï¼Œ`-type f` çš„æ„æ€æ˜¯ **åªåŒ¹é…æ™®é€šæ–‡ä»¶**ï¼ˆfileï¼‰ï¼Œè€Œä¸æ˜¯ç›®å½•ã€ç¬¦å·é“¾æ¥æˆ–å…¶ä»–ç‰¹æ®Šæ–‡ä»¶ã€‚

    æ¯”å¦‚ï¼š

    -   `-type f` â†’ æ™®é€šæ–‡ä»¶ï¼ˆregular fileï¼‰
    -   `-type d` â†’ ç›®å½•ï¼ˆdirectoryï¼‰
    -   `-type l` â†’ ç¬¦å·é“¾æ¥ï¼ˆlinkï¼‰

2.  `| xargs`ï¼šæŠŠ `find` è¾“å‡ºçš„å¤šè¡Œè·¯å¾„åˆå¹¶æˆ**ä¸€è¡Œï¼Œç©ºæ ¼åˆ†éš”**ã€‚

3.  `$( ... )`ï¼šå‘½ä»¤æ›¿æ¢ï¼ŒæŠŠåˆå¹¶åçš„ç»“æœèµ‹å€¼ç»™å˜é‡ `V_FILES`ã€‚

æœ€ç»ˆ `V_FILES` å°±æ˜¯ä¸€ä¸ªå˜é‡ï¼Œé‡Œé¢åŒ…å«äº†æ‰€æœ‰ `.v` æ–‡ä»¶çš„**ç»å¯¹è·¯å¾„æˆ–ç›¸å¯¹è·¯å¾„ï¼Œç”¨ç©ºæ ¼åˆ†éš”**ï¼Œæ–¹ä¾¿åç»­åœ¨è„šæœ¬é‡Œç›´æ¥å¼•ç”¨ã€‚



è¿™å¥æ˜¯ **bash è„šæœ¬é‡Œçš„ä½ç½®å‚æ•°èµ‹å€¼**ï¼Œé€å±‚è§£é‡Šï¼š

-   `$1`ï¼šè¡¨ç¤ºè„šæœ¬æ‰§è¡Œæ—¶ä¼ å…¥çš„ç¬¬ **ä¸€ä¸ªå‚æ•°**ã€‚
     æ¯”å¦‚ä½ æ‰§è¡Œï¼š

    ```
    ./myscript.sh /home/user/result
    ```

    é‚£ `$1` çš„å€¼å°±æ˜¯ `/home/user/result`ã€‚

-   `output_path=$1`ï¼šæŠŠç¬¬ä¸€ä¸ªå‚æ•°çš„å€¼èµ‹ç»™å˜é‡ `output_path`ã€‚
     æ‰€ä»¥åé¢è„šæœ¬é‡Œå°±å¯ä»¥ç”¨ `$output_path` æ¥å¼•ç”¨ï¼Œä¸ç”¨æ¯æ¬¡éƒ½å†™ `$1`



åœ¨ä½ è¿™ä»½è„šæœ¬é‡Œï¼Œ`mode` å¹¶ä¸æ˜¯å¤–éƒ¨ä¼ è¿›æ¥çš„å‚æ•°ï¼Œè€Œæ˜¯ **è„šæœ¬è‡ªå·±ç”Ÿæˆçš„å¾ªç¯å˜é‡**ï¼š

```shell
for mode in {4..8};
do
   echo "test-------------------$mode"
   if [ "$mode" -eq "4" ]; then
       ...
   elif [ "$mode" -eq "5" ]; then
       ...
   fi
done
```

æ„æ€æ˜¯ï¼š

-   è„šæœ¬è‡ªåŠ¨è®© `mode` ä¾æ¬¡å–å€¼ `4, 5, 6, 7, 8`
-   æ¯æ¬¡å¾ªç¯æ ¹æ® `mode` çš„å€¼æ‰§è¡Œå¯¹åº”çš„ `elif` åˆ†æ”¯
-   ä¸éœ€è¦ä½ åœ¨è¿è¡Œè„šæœ¬æ—¶ä¼ å…¥ `mode`



```shell
#!/bin/bash 
#æŒ‡å®šç›®æ ‡ç›®å½• 
target_dir="/home/pydu/Desktop/ip_changed_test/" 
#ç”Ÿæˆ dir_list.txt æ–‡ä»¶ 
find "$target_dir" -mindepth 2 -maxdepth 2 -printf '%p;%f\n' > dir_list.txt
```

è¿™ä¸ªè„šæœ¬çš„ä½œç”¨æ˜¯æ‰«ææŒ‡å®šç›®å½•ä¸‹çš„ **äºŒçº§å­ç›®å½•** å¹¶ç”Ÿæˆä¸€ä¸ªåˆ—è¡¨æ–‡ä»¶ï¼Œå…·ä½“è§£é‡Šå¦‚ä¸‹ï¼š

1.  `target_dir="/home/pydu/Desktop/ip_changed_test/"`
    -   æŒ‡å®šè¦æ‰«æçš„ç›®æ ‡ç›®å½•è·¯å¾„ã€‚
2.  `find "$target_dir" -mindepth 2 -maxdepth 2 -printf '%p;%f\n' > dir_list.txt`
    -   `find "$target_dir"`ï¼šä»ç›®æ ‡ç›®å½•å¼€å§‹æŸ¥æ‰¾æ–‡ä»¶/ç›®å½•ã€‚
    -   `-mindepth 2`ï¼šåªè€ƒè™‘ **æ·±åº¦ â‰¥ 2** çš„é¡¹ï¼Œä¹Ÿå°±æ˜¯ç›®æ ‡ç›®å½•çš„ **äºŒçº§å­ç›®å½•æˆ–æ–‡ä»¶**ã€‚
    -   `-maxdepth 2`ï¼šåªè€ƒè™‘ **æ·±åº¦ â‰¤ 2** çš„é¡¹ï¼Œæ‰€ä»¥æ­£å¥½åªæ‰«æäºŒçº§ã€‚
    -   `-printf '%p;%f\n'`ï¼šæ ¼å¼åŒ–è¾“å‡º
        -   `%p` â†’ æ–‡ä»¶/ç›®å½•çš„å®Œæ•´è·¯å¾„
        -   `%f` â†’ æ–‡ä»¶/ç›®å½•çš„åå­—ï¼ˆä¸å«è·¯å¾„ï¼‰
        -   `;` â†’ ä¸¤è€…ç”¨åˆ†å·åˆ†éš”
        -   `\n` â†’ æ¯è¡Œæ¢è¡Œ
    -   `> dir_list.txt`ï¼šæŠŠè¾“å‡ºå†™å…¥ `dir_list.txt` æ–‡ä»¶



## Pythonè„šæœ¬ï¼š

==re.sub==


1. åŸºæœ¬è¯­æ³•

```python
re.sub(pattern, repl, string, count=0, flags=0)
```

-   `pattern`ï¼šè¦åŒ¹é…çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œå¯ä»¥æ˜¯å­—ç¬¦ä¸²æˆ– compiled regex å¯¹è±¡
-   `repl`ï¼šæ›¿æ¢çš„å†…å®¹ï¼Œå¯ä»¥æ˜¯å­—ç¬¦ä¸²æˆ–å‡½æ•°
-   `string`ï¼šè¦å¤„ç†çš„æ–‡æœ¬
-   `count`ï¼šæœ€å¤§æ›¿æ¢æ¬¡æ•°ï¼Œé»˜è®¤ `0` è¡¨ç¤ºæ›¿æ¢æ‰€æœ‰åŒ¹é…
-   `flags`ï¼šæ­£åˆ™æ ‡å¿—ï¼Œå¦‚ `re.DOTALL`, `re.IGNORECASE` ç­‰

------

2. åŸºæœ¬ä¾‹å­

```python
import re

text = "Hello 123, world 456"
# æŠŠæ‰€æœ‰æ•°å­—æ›¿æ¢ä¸º X
new_text = re.sub(r'\d+', 'X', text)
print(new_text)  # è¾“å‡º: Hello X, world X
```

**r' çš„ä½œç”¨ï¼š**

åœ¨ Python å­—ç¬¦ä¸²é‡Œï¼š

```python
"\n"  # æ¢è¡Œç¬¦
"\t"  # åˆ¶è¡¨ç¬¦
```

å¦‚æœä½ å†™ `\\n` æ‰è¡¨ç¤ºä¸¤ä¸ªå­—ç¬¦ `\` å’Œ `n`ã€‚

ç”¨ `r'...'`ï¼Œåæ–œçº¿ `\` ä¸ä¼šè¢« Python è½¬ä¹‰ï¼Œè€Œæ˜¯åŸæ ·ä¼ ç»™æ­£åˆ™è¡¨è¾¾å¼ï¼š

```python
import re

pattern = r'\d+'  # \d è¡¨ç¤ºæ•°å­—
text = "123 abc"
print(re.findall(pattern, text))  # è¾“å‡º: ['123']
```

å¦‚æœä¸åŠ  `r`ï¼š

```
pattern = '\\d+'  # å¿…é¡»åŒåæ–œçº¿
print(re.findall(pattern, text))  # è¾“å‡º: ['123']
```

-   `\\d` åœ¨æ™®é€šå­—ç¬¦ä¸²é‡Œè¡¨ç¤º `\d`
-   `r'\d'` ç›´æ¥è¡¨ç¤º `\d`
-   å¯¹æ­£åˆ™æ¥è¯´ï¼Œå†™ `r'...'` æ›´ç›´è§‚ï¼Œä¸å®¹æ˜“å†™é”™

------

3. é™åˆ¶æ›¿æ¢æ¬¡æ•°

```python
text = "1 2 3 4"
new_text = re.sub(r'\d', 'n', text, count=2)
print(new_text)  # è¾“å‡º: n n 3 4
```

------

4. ä½¿ç”¨å‡½æ•°æ›¿æ¢

`repl` å¯ä»¥æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ª match å¯¹è±¡ï¼Œè¿”å›æ›¿æ¢å­—ç¬¦ä¸²ã€‚
 é€‚åˆåŠ¨æ€å¤„ç†æˆ–æ ¹æ®åŒ¹é…å†…å®¹æ›¿æ¢ã€‚

```python
def double_number(match):
    return str(int(match.group()) * 2)

text = "1 2 3"
new_text = re.sub(r'\d', double_number, text)
print(new_text)  # è¾“å‡º: 2 4 6
```

`double_number(match)` å‡½æ•°:

-   å½“ `re.sub` åŒ¹é…åˆ°ä¸€ä¸ªæ•°å­—æ—¶ï¼Œä¼šæŠŠåŒ¹é…å¯¹è±¡ `match` ä¼ ç»™è¿™ä¸ªå‡½æ•°
-   `match.group()` è¿”å›åŒ¹é…çš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ç¬¬ä¸€æ¬¡åŒ¹é…åˆ° `"1"`
-   `int(match.group())` å°†å­—ç¬¦ä¸² `"1"` è½¬æˆæ•´æ•° `1`
-   `* 2`ï¼šæ•°å­—ä¹˜ 2
-   `str(...)`ï¼šå†è½¬å›å­—ç¬¦ä¸²ï¼Œä½œä¸ºæ›¿æ¢å†…å®¹è¿”å›

------

5. å¸¸ç”¨ flags

-   `re.IGNORECASE` / `re.I`ï¼šå¿½ç•¥å¤§å°å†™
-   `re.MULTILINE` / `re.M`ï¼šè®© `^` å’Œ `$` åŒ¹é…æ¯è¡Œçš„å¼€å¤´å’Œç»“å°¾
-   `re.DOTALL` / `re.S`ï¼šè®© `.` åŒ¹é…åŒ…æ‹¬æ¢è¡Œç¬¦åœ¨å†…çš„æ‰€æœ‰å­—ç¬¦

ä¾‹å­ï¼š

```python
text = "Hello\nWorld"
# DOTALL è®© . åŒ¹é…æ¢è¡Œ
re.sub(r'.*', 'X', text, flags=re.DOTALL)  # è¾“å‡º: X
```

å¦‚æœ **ä¸åŠ  `re.DOTALL`**ï¼š

-   `.` é»˜è®¤ä¸åŒ¹é…æ¢è¡Œç¬¦
-   `.*` åªåŒ¹é…æ¯è¡Œçš„å†…å®¹
-   `re.sub` ä¼šå¯¹æ¯è¡Œåˆ†åˆ«åŒ¹é…ä¸€æ¬¡
-   é»˜è®¤åŒ¹é…æ–¹å¼æ˜¯ **é€è¡ŒåŒ¹é…**ï¼Œæ‰€ä»¥ `"Hello"` è¢«åŒ¹é…æ›¿æ¢ï¼Œ`\n` ä¿ç•™ï¼Œ`"World"` ä¹Ÿè¢«åŒ¹é…æ›¿æ¢

è¾“å‡ºç»“æœï¼š

```python
X
X
```

æ‰€ä»¥ä¸åŠ  `DOTALL` æ—¶ï¼Œæ¢è¡Œä¼šæŠŠæ–‡æœ¬æ‹†æˆå¤šæ®µåŒ¹é…ï¼Œæ¯è¡Œå•ç‹¬æ›¿æ¢ï¼›åŠ äº† `DOTALL` åˆ™æŠŠæ•´ä¸ªæ–‡æœ¬å½“ä½œä¸€ä¸ªæ•´ä½“åŒ¹é…ã€‚

------

6. æ•è·ç»„å’Œå¼•ç”¨

å¯ä»¥åœ¨ `repl` å­—ç¬¦ä¸²é‡Œç”¨ `\1, \2, ...` å¼•ç”¨æ•è·ç»„ï¼š

```python
text = "2025-10-31"
# äº¤æ¢å¹´æœˆæ—¥é¡ºåº
new_text = re.sub(r'(\d+)-(\d+)-(\d+)', r'\3/\2/\1', text)
print(new_text)  # è¾“å‡º: 31/10/2025
```

å¦‚æœç”¨å‡½æ•°ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ `match.group(1)` ç­‰è·å–ã€‚

`\1, \2, \3` å¼•ç”¨å‰é¢æ­£åˆ™çš„æ•è·ç»„

å¯¹ `"2025-10-31"` æ¥è¯´ï¼š

-   ç¬¬ 1 ç»„ â†’ `"2025"`
-   ç¬¬ 2 ç»„ â†’ `"10"`
-   ç¬¬ 3 ç»„ â†’ `"31"`
-   æ›¿æ¢å â†’ `"31/10/2025"`

------

7. æ›¿æ¢å¤šä¸ªä¸åŒæ¨¡å¼

ç”¨ `|` ç»„åˆæ¨¡å¼ï¼Œæˆ–è€…å†™å¤šä¸ª `re.sub`ï¼š

```python
text = "apple banana orange"
new_text = re.sub(r'apple|orange', 'fruit', text)
print(new_text)  # è¾“å‡º: fruit banana fruit
```

------

8. é«˜çº§ç¤ºä¾‹ï¼šæ¸…ç†ç‰¹å®šå±æ€§

åˆ é™¤ Verilog å±æ€§ï¼š

```python
content = re.sub(
    r'\(\*\s*OPT_MODIFIED\s*=\s*"PROPCONST"\s*\*\)\s*',
    '',
    content
)
```

è¯´æ˜ï¼š

-   `\(\*` å’Œ `\*\)` åŒ¹é… `(*` å’Œ `*)`
-   **`\s*` åŒ¹é…ç©ºæ ¼/ç©ºè¡Œ**ï¼š

`\s`ï¼šåŒ¹é…ä»»æ„ç©ºç™½å­—ç¬¦ï¼ŒåŒ…æ‹¬ï¼š

-   ç©ºæ ¼ `' '`
-   åˆ¶è¡¨ç¬¦ `\t`
-   æ¢è¡Œç¬¦ `\n`
-   å›è½¦ç¬¦ `\r`
-   å‚ç›´åˆ¶è¡¨ç¬¦ `\v` ç­‰

-   `*`ï¼šé‡è¯ï¼Œè¡¨ç¤ºâ€œ**å‰é¢çš„å…ƒç´ å‡ºç° 0 æ¬¡æˆ–å¤šæ¬¡**â€

æ‰€ä»¥ `\s*` çš„æ„æ€æ˜¯ **åŒ¹é… 0 ä¸ªæˆ–å¤šä¸ªç©ºç™½å­—ç¬¦**ã€‚

------

æ€»ç»“ï¼š

-   `re.sub` å¯ä»¥æ›¿æ¢å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥æ›¿æ¢å‡½æ•°è¿”å›å€¼
-   `count` æ§åˆ¶æ›¿æ¢æ¬¡æ•°
-   `flags` æ”¹å˜åŒ¹é…è§„åˆ™
-   æ•è·ç»„å¯ä»¥åœ¨æ›¿æ¢ä¸­å¼•ç”¨
-   ç”¨å‡½æ•°å¯ä»¥å¤„ç†åŠ¨æ€é€»è¾‘

==re.compile==

`re.compile` ç”¨æ¥ **é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼**ï¼Œç”Ÿæˆä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼å¯¹è±¡ï¼Œä»¥ä¾¿é‡å¤ä½¿ç”¨ï¼Œæ€§èƒ½æ›´å¥½ï¼Œå¹¶ä¸”å¯ä»¥è°ƒç”¨å¯¹è±¡çš„æ–¹æ³•è¿›è¡ŒåŒ¹é…ã€æœç´¢å’Œæ›¿æ¢ã€‚

------

1. åŸºæœ¬è¯­æ³•

```python
import re

pattern = re.compile(r'\d+')  # ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼
```

-   `r'\d+'`ï¼šæ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼ï¼ˆåŒ¹é…ä¸€ä¸ªæˆ–å¤šä¸ªæ•°å­—ï¼‰
-   `pattern` æ˜¯ä¸€ä¸ª **æ­£åˆ™è¡¨è¾¾å¼å¯¹è±¡**

------

2. ä½¿ç”¨æ–¹æ³•

æ­£åˆ™å¯¹è±¡å¸¸ç”¨æ–¹æ³•ï¼š

```python
text = "123 abc 456"

# matchï¼šä»å­—ç¬¦ä¸²å¼€å¤´åŒ¹é…
m = pattern.match(text)	#pattern å‰é¢å®šä¹‰ä¸ºåŒ¹é…æ•°å­—
print(m.group() if m else "No match")  # è¾“å‡º: 123

# searchï¼šæœç´¢æ•´ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªåŒ¹é…
s = pattern.search(text)
print(s.group())  # è¾“å‡º: 123

# findallï¼šæ‰¾åˆ°æ‰€æœ‰åŒ¹é…ï¼Œè¿”å›åˆ—è¡¨
f = pattern.findall(text)
print(f)  # è¾“å‡º: ['123', '456']

# subï¼šæ›¿æ¢
new_text = pattern.sub('X', text)
print(new_text)  # è¾“å‡º: X abc X
```

------

3. ä¼˜åŠ¿

1.  **é‡å¤ä½¿ç”¨æ•ˆç‡é«˜**

    ```python
    pattern = re.compile(r'\d+')
    for s in big_list:
        pattern.findall(s)
    ```

    -   å¦‚æœä¸ç¼–è¯‘ï¼Œæ¯æ¬¡è°ƒç”¨ `re.findall(r'\d+', s)` éƒ½è¦é‡æ–°è§£ææ­£åˆ™è¡¨è¾¾å¼

    -   æ¯æ¬¡å¾ªç¯éƒ½ä¼š **é‡æ–°è§£æ r'\d+'**ï¼Œç”Ÿæˆä¸´æ—¶æ­£åˆ™å¯¹è±¡

        å¯¹å°‘é‡æ–‡æœ¬å½±å“ä¸å¤§ï¼Œä½†å¤„ç†å¤§é‡æ•°æ®æ—¶ç•¥æ…¢

2.  **å¯ä»¥å’Œ flags ä¸€èµ·ä½¿ç”¨**

    ```python
    pattern = re.compile(r'\d+', re.IGNORECASE)
    ```

3.  **æ–¹ä¾¿æ–¹æ³•é“¾è°ƒç”¨**

    -   `pattern.match()`, `pattern.search()`, `pattern.findall()`, `pattern.sub()` ç­‰

```python
pattern = re.compile(
    r'(?P<attr>(?:\(\*[^)]*\*\)\s*)*)'
    r'(?P<name>[\\\w\[\]\$]+)\s*'
    r'(?:#\s*\(\s*(?P<params>.*?)\s*\)\s*)?'
    r'(?P<inst>\\[^\s()+]+|\w+)\s*'
    r'\((?P<ports>.*?)\)\s*;',
    re.DOTALL
)
```

è¿™ä¸€æ®µæ­£åˆ™ï¼š

```python
r'(?P<attr>(?:\(\*[^)]*\*\)\s*)*)'
```

1. `(?P<attr>...)`

-   `?P<attr>` æ˜¯ **å‘½åæ•è·ç»„**
-   æ•è·çš„å†…å®¹å¯ä»¥é€šè¿‡ `match.group("attr")` è·å–
-   è¿™é‡Œç”¨æ¥æ•è· **Verilog å±æ€§å—**

2. `(?:\(\*[^)]*\*\)\s*)`

-   `(?: ... )` â†’ **éæ•è·ç»„**ï¼Œåªæ˜¯ä¸ºäº†ç»„åˆæ­£åˆ™ï¼Œä¸å•ç‹¬æ•è·
-   `\(\*` â†’ åŒ¹é…å­—é¢é‡ `(*`
-   `[^)]*` â†’ åŒ¹é… **0 ä¸ªæˆ–å¤šä¸ªä¸æ˜¯å³æ‹¬å· `)` çš„å­—ç¬¦**
    -   æ³¨æ„ï¼šè¿™é‡Œç”¨äº† `)` è€Œä¸æ˜¯ `*`ï¼Œæ‰€ä»¥å¦‚æœå±æ€§é‡Œæœ‰ `*` ä¸ä¼šå½±å“
-   `\*\)` â†’ åŒ¹é…å­—é¢é‡ `*)`
-   `\s*` â†’ å±æ€§å—åå¯èƒ½æœ‰ç©ºæ ¼æˆ–æ¢è¡Œ

3.   å¤–å±‚ `*`

-   `(?:\(\*[^)]*\*\)\s*)*` â†’ åŒ¹é… **0 ä¸ªæˆ–å¤šä¸ªè¿™æ ·çš„å±æ€§å—**
-   ä¹Ÿå°±æ˜¯è¯´ï¼š
    -   å¯ä»¥æ²¡æœ‰å±æ€§
    -   å¯ä»¥æœ‰ä¸€æ¡å±æ€§
    -   å¯ä»¥æœ‰å¤šæ¡è¿ç»­å±æ€§ï¼Œæ¯æ¡åé¢å¯èƒ½æœ‰ç©ºæ ¼/æ¢è¡Œ

```python
r'(?P<name>[\\\w\[\]\$]+)\s*'
```

`[\\\w\[\]\$]+`

-   `[...]` â†’ å­—ç¬¦ç±»ï¼Œè¡¨ç¤ºåŒ¹é… **æ–¹æ‹¬å·å†…çš„ä»»æ„ä¸€ä¸ªå­—ç¬¦**
-   å†…éƒ¨å­—ç¬¦é€ä¸ªè§£é‡Šï¼š
    -   `\\` â†’ åŒ¹é…åæ–œæ  `\`ï¼ŒVerilog è½¬ä¹‰æ ‡è¯†ç¬¦å¸¸ç”¨
    -   `\w` â†’ åŒ¹é…å­—æ¯ã€æ•°å­—æˆ–ä¸‹åˆ’çº¿ `[A-Za-z0-9_]`
    -   `\[` â†’ åŒ¹é…å·¦æ–¹æ‹¬å· `[`
    -   `\]` â†’ åŒ¹é…å³æ–¹æ‹¬å· `]`
    -   `\$` â†’ åŒ¹é… `$` ç¬¦å·
-   `+` â†’ åŒ¹é… **1 ä¸ªæˆ–å¤šä¸ª**è¿™äº›å­—ç¬¦ç»„åˆ

-   **å’Œ `*` åŒºåˆ«ï¼š**
    -   `*` â†’ 0 æ¬¡æˆ–å¤šæ¬¡
    -   `+` â†’ 1 æ¬¡æˆ–å¤šæ¬¡

ä¸¾ä¾‹:

åŒ¹é…è¿ç»­æ•°å­—ï¼š

```python
import re
s = "123 4567 89"
re.findall(r'\d+', s)  # ['123', '4567', '89']
```

-   `\d` â†’ å•ä¸ªæ•°å­—
-   `\d+` â†’ åŒ¹é… 1 ä¸ªæˆ–å¤šä¸ªè¿ç»­æ•°å­—

åŒ¹é…å­—æ¯ä¸²ï¼š

```python
s = "abc 123 de"
re.findall(r'[a-z]+', s)  # ['abc', 'de']
```

-   `[a-z]` â†’ å•ä¸ªå°å†™å­—æ¯
-   `[a-z]+` â†’ 1 ä¸ªæˆ–å¤šä¸ªè¿ç»­å°å†™å­—æ¯

```python
r'(?:#\s*\(\s*(?P<params>.*?)\s*\)\s*)?'
```

1. `(?: ... )`

-   **éæ•è·ç»„**ï¼ˆnon-capturing groupï¼‰
-   åªæ˜¯ä¸ºäº†ç»„åˆæ­£åˆ™å†…éƒ¨ç»“æ„ï¼Œä¸å•ç‹¬æ•è·
-   è¿™é‡Œç»„åˆäº†æ•´ä¸ª `#(...)` å‚æ•°å—

2. `#`

-   åŒ¹é…å­—é¢é‡ `#`
-   åœ¨ Verilog ä¸­è¡¨ç¤ºå‚æ•°åŒ–å®ä¾‹åŒ–ï¼Œä¾‹å¦‚ï¼š

```verilog
RAMB18E2 #(
    .DOA_REG(0)
) mem_reg (...);
```

-   `#(` å°±æ˜¯å‚æ•°å—çš„å¼€å§‹

3.   `(?P<params>.*?)`

-   å‘½åæ•è·ç»„ `params`
-   `.*?` â†’ **éè´ªå©ªåŒ¹é…ä»»æ„å­—ç¬¦**
    -   åŒ¹é…æœ€å°‘å­—ç¬¦ç›´åˆ°é‡åˆ°ä¸‹ä¸€ä¸ªæ¨¡å¼ï¼ˆè¿™é‡Œæ˜¯ `)`ï¼‰å› ä¸ºåé¢ä¼šè¯†åˆ« `\s*\)`
-   æ•è·çš„å†…å®¹å°±æ˜¯ **å‚æ•°åˆ—è¡¨å†…å®¹**ï¼Œä¾‹å¦‚ï¼š

```
.DO_REG(0), .DOB_REG(1)
```

4.   `?`ï¼ˆæ•´ä¸ªéæ•è·ç»„æœ«å°¾ï¼‰

-   è¡¨ç¤º **0 æ¬¡æˆ– 1 æ¬¡**
-   ä¹Ÿå°±æ˜¯è¯´ **å‚æ•°å—æ˜¯å¯é€‰çš„**
-   å¯ä»¥åŒ¹é…æœ‰å‚æ•°çš„å®ä¾‹ï¼Œä¹Ÿå¯ä»¥åŒ¹é…æ— å‚æ•°çš„å®ä¾‹

```python
r'(?P<inst>\\[^\s()+]+|\w+)\s*'
```

 `\\[^\s()+]+`

-   `\\` â†’ åŒ¹é…å­—é¢é‡åæ–œæ  `\`ï¼ŒVerilog è½¬ä¹‰æ ‡è¯†ç¬¦å¸¸ç”¨
-   `[^\s()+]+` â†’ åŒ¹é… **1 ä¸ªæˆ–å¤šä¸ªéç©ºç™½å­—ç¬¦ã€éæ‹¬å· `()`ã€éåŠ å· `+`**
-   ä½œç”¨ï¼šåŒ¹é…å½¢å¦‚ï¼š

```
\putbuffer/tail_ext/Memory_reg_0_15_0_0
```

-   æ³¨æ„è¿™é‡Œ **å®ä¾‹åå‰å¸¦åæ–œæ **ï¼Œæ­£åˆ™å°±åŒ¹é…æ•´ä¸ªåå­—ç›´åˆ°é‡åˆ°ç©ºæ ¼æˆ– `()`

 `|\w+`

-   `|` â†’ æˆ–
-   `\w+` â†’ åŒ¹é… **å­—æ¯ã€æ•°å­—æˆ–ä¸‹åˆ’çº¿** ç»„æˆçš„æ™®é€šå®ä¾‹å
-   ä½œç”¨ï¼šåŒ¹é…æ²¡æœ‰è½¬ä¹‰ç¬¦çš„æ™®é€šåå­—ï¼Œä¾‹å¦‚ï¼š

```
UART_OBUF_inst
```

```python
r'\((?P<ports>.*?)\)\s*;'
```

`(?P<ports>.*?)`

-   å‘½åæ•è·ç»„ `ports`
-   æ•è·æ‹¬å·å†…çš„ **ç«¯å£è¿æ¥å†…å®¹**
-   `.*?` â†’ **éè´ªå©ªåŒ¹é…ä»»æ„å­—ç¬¦**
    -   ä¼šå°½é‡å°‘åŒ¹é…ï¼Œç›´åˆ°é‡åˆ°åé¢çš„å³æ‹¬å· `)`

==primitiveæ›¿æ¢è„šæœ¬ï¼š==

```python
import re

# ==== é…ç½®æ–‡ä»¶å ====
input_file = "input.v"
output_file = "top_out.v"

with open(input_file, "r") as f:
    code = f.read()

# ==== åŒ¹é…æ¨¡å—ä¾‹åŒ– ====
# æ”¯æŒæ™®é€šå®ä¾‹åå’Œåæ–œæ +æ•°ç»„ç´¢å¼•å®ä¾‹å
inst_pattern = re.compile(
    r'(\w+)\s*#\s*\((.*?)\)\s*(\\?[\w\.\[\]]+)\s*\((.*?)\);',
    re.S
)

match = inst_pattern.search(code)
if not match:
    print("âŒ æœªæ‰¾åˆ°æ¨¡å—ä¾‹åŒ–")
    exit(1)

mod_name, param_block, inst_name, port_block = match.groups()
print(f"Found instance: {inst_name} of module {mod_name}")

# ==== æå–å‚æ•° ====
params = []
for p in re.findall(r'\.(\w+)\s*\(\s*([^)]+)\s*\)', param_block):
    pname, pvalue = p
    params.append((pname, pvalue.strip()))

# ==== è®¡ç®—ç«¯å£å®½åº¦å‡½æ•° ====
def calc_width(sig):
    sig = sig.strip()
    # å¤šä¿¡å·ç»„åˆï¼Œç”¨é€—å·åˆ†éš”
    parts = [x.strip() for x in sig.split(',')]
    total_width = 0
    for p in parts:
        # åŒ¹é… [msb:lsb]
        bw_match = re.search(r'\[(\d+):(\d+)\]', p)
        if bw_match:
            msb, lsb = map(int, bw_match.groups())
            total_width += abs(msb - lsb) + 1
        else:
            total_width += 1  # å•æ¯”ç‰¹æˆ–å¸¸é‡
    if total_width > 1:
        return f"[{total_width-1}:0] "
    else:
        return ""  # å•æ¯”ç‰¹ä¸åŠ ä½å®½

# ==== æå–ç«¯å£ ====
ports = []
for p in re.findall(r'\.(\w+)\s*\(\s*([^)]+)\s*\)', port_block):
    port_name, sig = p
    width = calc_width(sig)
    ports.append((port_name, width))

# ==== ç”Ÿæˆè¾“å‡º ====
lines = []
lines.append(f"module {mod_name} #(\n")
for pname, pvalue in params:
    lines.append(f"    parameter {pname} = {pvalue},\n")
if params:
    lines[-1] = lines[-1].rstrip(",\n") + "\n"
lines.append(") (\n")
for port_name, width in ports:
    lines.append(f"    input {width}{port_name},\n")
if ports:
    lines[-1] = lines[-1].rstrip(",\n") + "\n"
lines.append(");\n\nendmodule\n")

with open(output_file, "w") as f:
    f.writelines(lines)

print(f"âœ… é¡¶å±‚å‚æ•° + IO å·²ç”Ÿæˆåˆ° {output_file}")
```

åˆ†æï¼š

```python
inst_pattern = re.compile(
    r'(\w+)\s*#\s*\((.*?)\)\s*(\\?[\w\.\[\]]+)\s*\((.*?)\);',
    re.S
)
```

**æ­£åˆ™è§£é‡Š**ï¼š

1.  `(\w+)` â†’ åŒ¹é…æ¨¡å—åï¼Œä¾‹å¦‚ `GTYE4_CHANNEL`
2.  `#\s*\((.*?)\)` â†’ åŒ¹é…å‚æ•°åˆ—è¡¨ `#(...)`ï¼Œæ•è·é‡Œé¢çš„å†…å®¹
3.  `(\\?[\w\.\[\]]+)` â†’ åŒ¹é…å®ä¾‹åï¼š
    -   å¯ä»¥æ˜¯æ™®é€šåå­— `pcie_inst`
    -   æˆ–å¸¦åæ–œæ ã€ç‚¹å·å’Œæ•°ç»„ç´¢å¼• `\gtye4_channel_gen.gen_gtye4_channel_inst[0].GTYE4_CHANNEL_PRIM_INST`
4.  `\((.*?)\)` â†’ åŒ¹é…ç«¯å£æ˜ å°„å— `( ... )`

`re.S` â†’ è®© `.` åŒ¹é…æ¢è¡Œç¬¦

```python
match = inst_pattern.search(code)
if not match:
    print("âŒ æœªæ‰¾åˆ°æ¨¡å—ä¾‹åŒ–")
    exit(1)

mod_name, param_block, inst_name, port_block = match.groups()
print(f"Found instance: {inst_name} of module {mod_name}")
```

`inst_pattern` æ˜¯ä½ ä¹‹å‰ç”¨ `re.compile(...)` ç¼–è¯‘å¥½çš„æ­£åˆ™å¯¹è±¡ã€‚

`.search(code)` ä¼šåœ¨æ•´ä¸ªå­—ç¬¦ä¸² `code`ï¼ˆå³ä½ çš„ Verilog æ–‡ä»¶å†…å®¹ï¼‰ä¸­ **æœç´¢ç¬¬ä¸€ä¸ªåŒ¹é…**æ­£åˆ™æ¨¡å¼çš„å­ä¸²ã€‚

è¿”å›å€¼ `match` æ˜¯ä¸€ä¸ª **åŒ¹é…å¯¹è±¡**ï¼ˆ`re.Match`ï¼‰ï¼Œå®ƒåŒ…å«ï¼š

-   æ˜¯å¦åŒ¹é…æˆåŠŸï¼ˆ`match is None` è¡¨ç¤ºæ²¡åŒ¹é…åˆ°ï¼‰
-   åŒ¹é…åˆ°çš„å®Œæ•´æ–‡æœ¬ï¼ˆ`match.group(0)`ï¼‰
-   æ¯ä¸ªæ•è·ç»„çš„å†…å®¹ï¼ˆ`match.groups()` æˆ– `match.group(1)`ã€`match.group(2)` ç­‰ï¼‰

Python `re` è§„å®šï¼š**æ¯å¯¹ `()` æ‹¬å·å°±æ˜¯ä¸€ä¸ªæ•è·ç»„**

`.groups()` ä¼šè¿”å› **æ‰€æœ‰æ•è·ç»„çš„å†…å®¹**ï¼Œé¡ºåºå°±æ˜¯æ­£åˆ™é‡Œæ‹¬å·å‡ºç°çš„é¡ºåº

```python
# ==== æå–å‚æ•° ====
params = []
for p in re.findall(r'\.(\w+)\s*\(\s*([^)]+)\s*\)', param_block):
    pname, pvalue = p
    params.append((pname, pvalue.strip()))
```

`param_block` æ˜¯ **æ¨¡å—ä¾‹åŒ–é‡Œ `#(...)` çš„å†…å®¹**ï¼Œä¾‹å¦‚ï¼š

```
.AEN(1'b1),
.A_FBDIV(16)
```

1.  `re.findall(pattern, param_block)` ä¼š **æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…æ­£åˆ™çš„å­ä¸²**ï¼Œè¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œå¯¹åº”æ•è·ç»„ã€‚

------

æ­£åˆ™è§£é‡Š

```
\.(\w+)\s*\(\s*([^)]+)\s*\)
```

-   `\.` â†’ åŒ¹é…å­—é¢ç‚¹å· `.`ï¼Œå› ä¸º Verilog å‚æ•°å’Œç«¯å£éƒ½æ˜¯ `.åå­—(å€¼)`
-   `(\w+)` â†’ **æ•è·ç»„ 1**ï¼Œå‚æ•°åï¼Œæ¯”å¦‚ `AEN` æˆ– `A_FBDIV`
-   `\s*` â†’ å¯æœ‰å¯æ— çš„ç©ºæ ¼
-   `\(` â†’ åŒ¹é…å·¦æ‹¬å· `(`ï¼Œ**æ²¡æœ‰åŒ…åœ¨ `()` é‡Œ**ï¼Œæ‰€ä»¥ä¸æ˜¯æ•è·ç»„
-   `([^)]+)` â†’ **æ•è·ç»„ 2ï¼Œæ‹¬å·å†…çš„å€¼ï¼ˆç›´åˆ°é‡åˆ°å³æ‹¬å· `)`ï¼‰**ï¼Œæ¯”å¦‚ `1'b1` æˆ– `16`
-   `\s*` â†’ å¯æœ‰å¯æ— çš„ç©ºæ ¼
-   `\)` â†’ åŒ¹é…å³æ‹¬å·

------

å¾ªç¯å¤„ç†

```python
for p in re.findall(...):
    pname, pvalue = p
    params.append((pname, pvalue.strip()))
```

-   æ¯ä¸ªåŒ¹é…çš„å…ƒç»„ `p`ï¼š`(å‚æ•°å, å‚æ•°å€¼)`
-   `pvalue.strip()` â†’ å»æ‰å‰åç©ºæ ¼
-   å­˜å…¥åˆ—è¡¨ `params`ï¼Œæ–¹ä¾¿åé¢ç”Ÿæˆé¡¶å±‚ `parameter`

å‡è®¾ `param_block` æ˜¯ï¼š

```
.AEN(1'b1),
.A_FBDIV(16)
```

-   `re.findall(...)` è¿”å›ï¼š

```
[('AEN', "1'b1"), ('A_FBDIV', '16')]
```

-   `params` æœ€ç»ˆæ˜¯ï¼š

```
[('AEN', "1'b1"), ('A_FBDIV', '16')]
```



**ä¸Šåº“è„šæœ¬ï¼šï¼ˆpythonï¼‰**

```python
import os	# æ“ä½œæ–‡ä»¶å’Œç›®å½•
import subprocess
import argparse
from concurrent.futures import ProcessPoolExecutor

def find_folders_with_keyword(path, keyword):
    matching_folders = []	# åˆå§‹åŒ–ç©ºåˆ—è¡¨ matching_folders ç”¨æ¥å­˜æ”¾åŒ¹é…çš„æ–‡ä»¶å¤¹è·¯å¾„
    if not os.path.exists(path):
        return matching_folders
    try:
        for folder_name in os.listdir(path):	#ç”¨ os.listdir(path) éå† path ä¸‹çš„æ‰€æœ‰æ¡ç›®
            full_path = os.path.join(path, folder_name) # os.path.join(path, folder_name) å¾—åˆ°å®Œæ•´è·¯å¾„
            if os.path.isdir(full_path) and keyword in folder_name:
                matching_folders.append(full_path) # æ»¡è¶³æ˜¯ç›®å½•ä»¥åŠåŒ…å«å…³é”®å­—ï¼Œå°±åŠ å…¥ matching_folders
    except Exception as e: # æ•è·å¼‚å¸¸ï¼Œå¦‚æœéå†è¿‡ç¨‹ä¸­å‡ºé”™ï¼ˆä¾‹å¦‚æƒé™é—®é¢˜ï¼‰ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯å­—ç¬¦ä¸²
        return f"An error occurred: {e}"
    return matching_folders # æœ€ç»ˆè¿”å›åŒ¹é…çš„æ–‡ä»¶å¤¹åˆ—è¡¨
```

åœ¨ Python ä¸­ï¼Œ`try` æ˜¯ **å¼‚å¸¸å¤„ç†æœºåˆ¶**çš„ä¸€éƒ¨åˆ†ï¼Œç”¨æ¥æ•è·å¯èƒ½åœ¨è¿è¡Œæ—¶å‘ç”Ÿçš„é”™è¯¯ï¼Œé˜²æ­¢ç¨‹åºç›´æ¥å´©æºƒã€‚åŸºæœ¬ç”¨æ³•æ˜¯ï¼š

```python
try:
    # å¯èƒ½ä¼šå‡ºé”™çš„ä»£ç 
    result = 10 / 0
except Exception as e:
    # å‡ºé”™æ—¶æ‰§è¡Œçš„ä»£ç 
    print(f"å‡ºé”™äº†: {e}")
```

è§£é‡Šï¼š

-   `try` å—é‡Œçš„ä»£ç ä¼šè¢«æ‰§è¡Œã€‚
-   å¦‚æœå‡ºç°å¼‚å¸¸ï¼ˆæ¯”å¦‚é™¤ä»¥é›¶ã€æ–‡ä»¶ä¸å­˜åœ¨ç­‰ï¼‰ï¼ŒPython ä¼šè·³åˆ° `except` å—æ‰§è¡Œå¯¹åº”å¤„ç†ã€‚
-   `Exception as e` ä¼šæŠŠé”™è¯¯ä¿¡æ¯ä¿å­˜åˆ°å˜é‡ `e` ä¸­ï¼Œæ–¹ä¾¿æ‰“å°æˆ–è®°å½•ã€‚
-   å¦‚æœ `try` é‡Œçš„ä»£ç æ²¡æŠ¥é”™ï¼Œ`except` å—ä¼šè¢«è·³è¿‡ã€‚

```python
def adjust_paths(root_path, paths):	# ç”¨äºæŠŠä¸€ç»„è·¯å¾„è°ƒæ•´ä¸ºç»å¯¹è·¯å¾„
    adjusted_paths = []
	if not root_path.endswith('/'):	# ç¡®ä¿ root_path ä»¥ / ç»“å°¾ï¼Œæ–¹ä¾¿åç»­æ‹¼æ¥è·¯å¾„
    	root_path = root_path + '/'
	parent_path = os.path.dirname(root_path) #è·å– root_path çš„ä¸Šçº§ç›®å½•ï¼Œä¸ºäº†ä»ç›¸å¯¹è·¯å¾„è½¬åŒ–ä¸ºç»å¯¹è·¯å¾„
	for path in paths:
	    if path.startswith('../'): # ä½¿ç”¨ os.path.join(parent_path, path) æŠŠçˆ¶ç›®å½•å’Œç›¸å¯¹è·¯å¾„æ‹¼æ¥èµ·æ¥
	        normalized_path = os.path.normpath(os.path.join(parent_path, path))
	    else:
	        normalized_path = os.path.join(root_path, path)
	    adjusted_paths.append(normalized_path)
	return adjusted_paths
```

```python
 # æ‰¾ç¬¬ä¸€ä¸ªç¬¦åˆæ–‡ä»¶åç¼€ + è·¯å¾„åŒ…å«å…³é”®å­—çš„æ–‡ä»¶
def find_first_file_with_suffix_and_content(root_path, suffix, keyword):
    for root, _, files in os.walk(root_path): #éå† root_path ä¸‹æ‰€æœ‰å­ç›®å½•å’Œæ–‡ä»¶ï¼ˆos.walk ä¼šé€’å½’å­ç›®å½•ï¼‰
        for file in files:
            if file.endswith(suffix):
                file_path = os.path.join(root, file)
                if keyword in file_path:
                    return file_path
    return None

# å¿«é€Ÿæ‰¾åˆ°æ–‡ä»¶ä¸­ç¬¬ä¸€è¡ŒåŒ…å«æŸå­—ç¬¦çš„å†…å®¹
def find_first_line_with_char(file_path, search_char):
    with open(file_path, 'r') as file: # æ‰“å¼€æŒ‡å®šæ–‡ä»¶ file_pathï¼Œé€è¡Œè¯»å–
        for line in file:
            if search_char in line: # æ‰¾åˆ°ç¬¬ä¸€è¡ŒåŒ…å«æŒ‡å®šå­—ç¬¦ search_char çš„è¡Œ
                return line.strip() # ç”¨ strip() å»æ‰è¡Œé¦–å°¾ç©ºç™½å¹¶è¿”å›
    return '' #å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸² ''

# åˆ—å‡ºç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶ï¼ŒåŒæ—¶æ’é™¤æŒ‡å®šæ–‡ä»¶
def list_files_excluding(path, exclude_files):
    all_files = []
    for item in os.listdir(path):
        item_path = os.path.join(path, item) # éå†æŒ‡å®šç›®å½• path ä¸‹çš„æ‰€æœ‰æ¡ç›®
        if os.path.isfile(item_path) and item not in exclude_files: #å¦‚æœæ¡ç›®æ˜¯æ–‡ä»¶ä¸”ä¸åœ¨ exclude_files åˆ—è¡¨ä¸­ï¼Œå°±åŠ å…¥ all_files
            all_files.append(item_path)
    return all_files
```

```python
# åœ¨ folder_path ç›®å½•ä¸‹ï¼Œæ‰¾åˆ°åå­—é‡ŒåŒ…å« search_char çš„æ‰€æœ‰æ–‡ä»¶å¤¹ã€‚
def get_folders_with_character(folder_path, search_char):
    matching_folders = []
    for entry in os.listdir(folder_path):
        full_path = os.path.join(folder_path, entry)
        if os.path.isdir(full_path) and search_char in entry:
            matching_folders.append(full_path)
    return matching_folders

# æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼ŒæŠŠå†…å®¹é‡Œå‡ºç°çš„ key å…¨éƒ¨æ›¿æ¢æˆ valueã€‚
def replace_func(destination_path, replacements):
    with open(destination_path, 'r+') as file:
        file_content = file.read()
        for key, value in replacements.items():
            file_content = file_content.replace(key, value)
        file.seek(0)
        file.write(file_content)
        file.truncate()

# æŠŠæ–‡ä»¶æŒ‰è¡Œè¯»å…¥ï¼Œå¹¶å»æ‰æ¯è¡Œé¦–å°¾çš„ç©ºæ ¼/æ¢è¡Œç¬¦ï¼Œè¿”å›åˆ—è¡¨ã€‚
def read_file_to_list(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        lines = file.readlines()
    return [line.strip() for line in lines]

# è¿è¡Œä¸€ä¸ª shell å‘½ä»¤ï¼Œå¹¶æ•è·è¾“å‡ºæˆ–é”™è¯¯ã€‚
def run_command(command):
    try:
        result = subprocess.run(
            command, shell=True, check=True,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        print(f"Output for {command}: {result.stdout.decode()}")
    except subprocess.CalledProcessError as e:
        print(f"Error executing {command}: {e.stderr.decode()}")
```

å…³é”®éƒ¨åˆ†ï¼š

```python
if __name__ == '__main__':	# åªæœ‰åœ¨ç›´æ¥è¿è¡Œè¿™ä¸ªè„šæœ¬çš„æ—¶å€™ï¼Œé‡Œé¢çš„ä»£ç æ‰ä¼šæ‰§è¡Œ
    parser = argparse.ArgumentParser(prog='EccadTest System') #å»ºç«‹ä¸€ä¸ªå‘½ä»¤è¡Œè§£æå™¨ï¼Œç¨‹åºåæ˜¾ç¤ºä¸º "EccadTest System"

    parser.add_argument(	#å®šä¹‰å‚æ•° -l æˆ– --caseListï¼Œå­˜åˆ° args.caseList
        '-l', '--caseList',
        dest='caseList',
        default=None,
        required=True
    )

    parser.add_argument(	# å‚æ•° -d æˆ– --resultDirï¼Œå­˜åˆ° args.resultDirï¼›
        '-d', '--resultDir',
        dest='resultDir',
        metavar='[resultDir]',
        required=True,
        help='please input resultDir, this is required'
    )

    parser.add_argument(
        '-pa', '--part',
        dest='part',
        metavar='[part]',
        required=True
    )

    parser.add_argument(
        '-pv', '--version',
        dest='version',
        metavar='[version]',
        required=True
    )

    args = parser.parse_args()	# ä»å‘½ä»¤è¡Œè¯»å–ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ï¼Œå¹¶å­˜å…¥ args

    target_path = args.resultDir	# æŠŠè§£æå‡ºæ¥çš„å‚æ•°èµ‹å€¼åˆ°æœ¬åœ°å˜é‡é‡Œå¤‡ç”¨
    input_list = args.caseList
    part = args.part
    precision_version = args.version
```

ä¸¾ä¸ªè¿è¡Œä¾‹å­ï¼š

```
python script.py -l cases.txt -d ./results -pa partA -pv v1.0
```

è¿™æ ·æ‰§è¡Œåï¼Œå˜é‡ä¼šæ˜¯ï¼š

-   `target_path = "./results"`
-   `input_list = "cases.txt"`
-   `part = "partA"`
-   `precision_version = "v1.0"`

è¿™å¥ï¼š

```
if __name__ == '__main__':
```

æ„æ€æ˜¯ï¼šåªæœ‰åœ¨ **ç›´æ¥è¿è¡Œè¿™ä¸ªè„šæœ¬** çš„æ—¶å€™ï¼Œé‡Œé¢çš„ä»£ç æ‰ä¼šæ‰§è¡Œã€‚

-   å¦‚æœä½ æ‰§è¡Œ

    ```
    python script.py ...
    ```

    é‚£ä¹ˆ `__name__` å°±ä¼šç­‰äº `"__main__"`ï¼Œæ‰€ä»¥é‡Œé¢çš„ä»£ç ä¼šè¿è¡Œã€‚

-   å¦‚æœä½ åœ¨åˆ«çš„è„šæœ¬é‡Œ

    ```
    import script
    ```

    é‚£ä¹ˆ `__name__` å°±ä¼šç­‰äº `"script"`ï¼Œä¸ä¼šè§¦å‘ `if` é‡Œçš„ä»£ç ã€‚

```python
synth_insert_io = True

files = ['edc', 'netlist', 'ods', 'rtl', 'sdc', 'local_test']
ori   = ['edc', 'rtl', 'sdc']

extension = ['.edc', '.sdc']
exclude_file_name = 'debug.edc'

edcTotalFile = '/shares/edatest/caihao/Archiving_Tool/edcList.txt'
sdcTotalFile = '/shares/edatest/caihao/Archiving_Tool/sdcList.txt'

global caselist, commands, check_string
caselist = []
commands = []
check_string = ''

dir_list = read_file_to_list(input_list) # è¯»å–è¾“å…¥çš„ç›®å½•æ¸…å•æ–‡ä»¶ï¼Œå¾—åˆ°ä¸€ä¸ªç›®å½•åˆ—è¡¨

for dir in dir_list: # éå†æ¯ä¸ªç›®å½•ï¼Œå¹¶åˆå§‹åŒ–ä¸€äº›å˜é‡ï¼ˆåˆæˆçº¦æŸã€RTL åˆ—è¡¨ã€ç½‘è¡¨è·¯å¾„ç­‰ï¼‰
    top = ''
    synth_constr = []
    ip_flag = False
    rtls = []
    ip_synth_1 = []
    netlist_path = ''

    # æŸ¥æ‰¾ .flow ç›®å½•
    ods_prj_path_list = find_flow_folders(dir.split(';')[0]) # dir.split(';')[0] â†’ å‰åŠéƒ¨åˆ†æ˜¯ç›®å½•è·¯å¾„ï¼Œ; åé¢æ˜¯ case åå­—
    print(ods_prj_path_list)

    if len(ods_prj_path_list) != 1:
        print('\n### Error! ods_prj_path: ' + dir.split(';')[0] + '/.flow not exists!')
        exit(0)
    else:
        ods_prj_path = '/'.join(
            ods_prj_path_list[0].rstrip('/').rsplit('/', 1)[:-1]
        ) + '/'
        case_name = dir.split(';')[1]
        caselist.append(case_name)
        
       # begin run
	   flow_path_list = find_folders_with_keyword(ods_prj_path, '.flow') # åœ¨ ods_prj_path ç›®å½•ä¸‹æŸ¥æ‰¾åå­—é‡ŒåŒ…å« .flow çš„æ–‡ä»¶å¤¹ï¼Œç»“æœå­˜åœ¨ flow_path_list
	   if len(flow_path_list) == 1:
	       flow_path = flow_path_list[0] + '/'
	   elif len(flow_path_list) == 0:
	       print('\n### Error! ods_prj_path: ' + ods_prj_path + ' not exists!')
	       exit(0)
	   else:
	       print('\n### Error! Too many directory \'.flows\' ,pls check!')
	       exit(1)
	   
	   src_path_list = find_folders_with_keyword(ods_prj_path, '.src') # æŸ¥æ‰¾ .src æ–‡ä»¶å¤¹
	   if len(src_path_list) == 1:
	       src_path = src_path_list[0] + '/'
	   elif len(src_path_list) == 0:
	       print('\n### Error! ods_prj_path: ' + ods_prj_path + ' not exists!')
	       exit(0)
	   else:
	       print('\n### Error! Too many directory \'.srcs\' ,pls check!')
	       exit(1)
	
       # do archiving
	   if os.path.exists(flow_path+'synth_1/debug_synth.tcl'):
	       print('\n### '+case_name+' begin archiving... May cost some time, pls wait, thanks...\n')
	       
	       with open(flow_path+'synth_1/debug_synth.tcl', 'r', encoding='utf-8') as file:
	           lines = file.readlines() # è¯»å–æ–‡ä»¶æ‰€æœ‰è¡Œåˆ° lines åˆ—è¡¨
	       
           # è§£ææ–‡ä»¶å†…å®¹ï¼Œæå– RTL/IP/çº¦æŸåˆ—è¡¨
	       for line in lines:
	           if 'lappend hdl_src_list' in line:
	               line = line.split('ECCAD_PROJECT_PATH ')[1].split(']')[0]
	               rtls.append(line)
	           if 'lappend ip_list' in line:
	               ip_flag = True
	               line = line.split('ECCAD_PROJECT_PATH ')[1].split(']')[0]
	               ip_synth_1.append(line)
	           if 'lappend cnst_src_list' in line and 'debug.edc' in line:
	               line = line.split('ECCAD_PROJECT_PATH ')[1].split(']')[0]
	               synth_constr.append(line)
	   
	       print(rtls)
	       rtls = adjust_paths(ods_prj_path, rtls) # è°ƒæ•´è·¯å¾„ä¸ºç»å¯¹è·¯å¾„
	       ip_synth_1 = adjust_paths(ods_prj_path, ip_synth_1)
	       synth_constr = adjust_paths(ods_prj_path, synth_constr)
	   
	   # åˆ›å»ºç›®æ ‡ç›®å½•
	   if not os.path.exists(target_path+'/'+case_name):
	       print('mkdir '+target_path+'/'+case_name)
	       os.system('mkdir -p '+target_path+'/'+case_name)
	   
	   for file in files: # åˆ›å»ºå­ç›®å½•å’Œç‰¹æ®Šå­ç›®å½•
	       os.system('mkdir -p '+target_path+'/'+case_name+'/'+file)
	       if file in ori:
	           os.system('mkdir -p '+target_path+'/'+case_name+'/'+file+'/ori')
	       if file == 'netlist':
	           os.system('mkdir -p '+target_path+'/'+case_name+'/'+file+'/'+precision_version)


```





# æ—¥å¸¸å·¥ä½œï¼š

å‘¨æŠ¥è¿›åº¦ï¼š

![image-20250916100151131](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250916100151131.png)



## DSPï¼š

åœ¨ Verilog å¼€å‘é‡Œè¯´çš„ **DSP**ï¼Œé€šå¸¸æŒ‡çš„æ˜¯ FPGA æˆ– ASIC é‡Œçš„ **æ•°å­—ä¿¡å·å¤„ç†å•å…ƒ**ã€‚

1.  **åº•å±‚å«ä¹‰**ï¼šFPGA èŠ¯ç‰‡é‡Œä¼šé›†æˆç¡¬ä»¶ä¹˜æ³•å™¨/ç´¯åŠ å™¨ï¼ˆMACï¼ŒMultiply-Accumulateï¼‰ï¼Œå‚å®¶ä¸€èˆ¬ç§°ä¸º **DSP Slice / DSP Block**ã€‚å®ƒä»¬èƒ½é«˜æ•ˆåšä¹˜æ³•ã€åŠ æ³•ã€ç´¯åŠ ï¼Œé€Ÿåº¦è¿œå¿«äºç”¨æ™®é€šé€»è¾‘å•å…ƒå®ç°ã€‚
2.  **å¼€å‘è§’åº¦**ï¼šåœ¨ Verilog é‡Œå†™ä¹˜æ³•ã€ä¹˜åŠ ç­‰è¿ç®—æ—¶ï¼Œç»¼åˆå·¥å…·ä¼šè‡ªåŠ¨æŠŠå®ƒä»¬æ˜ å°„åˆ° DSP å•å…ƒï¼Œè€Œä¸æ˜¯ç”¨ LUT å®ç°ã€‚
3.  **åº”ç”¨**ï¼šä¸»è¦ç”¨åœ¨æ»¤æ³¢å™¨ã€FFTã€å›¾åƒ/éŸ³é¢‘å¤„ç†ã€å·ç§¯åŠ é€Ÿã€æœºå™¨å­¦ä¹ ç­‰é«˜æ€§èƒ½è®¡ç®—æ¨¡å—ã€‚

è¦ç‚¹ï¼šVerilog é‡Œ DSP å¹¶ä¸æ˜¯ä¸€ç§è¯­è¨€ç‰¹æ€§ï¼Œè€Œæ˜¯ç¡¬ä»¶èµ„æº/ç»“æ„ï¼Œå†™æ³•ä¸Šå°±æ˜¯æ™®é€šçš„ `*`ã€`+`ã€`acc <= acc + a*b;`ï¼Œæœ€ç»ˆç”±ç»¼åˆå·¥å…·æ˜ å°„åˆ° DSP ç¡¬æ ¸ã€‚



è·‘é€šDSP flowï¼š

![image-20250916094301598](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250916094301598.png)

èŠ¯ç‰‡è·‘çš„æ—¶å€™ç”¨8MIN

TC2èŠ¯ç‰‡ä½¿ç”¨EC9H200-ES-8MIN

![image-20250916113956073](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250916113956073.png)

tclè„šæœ¬ï¼š

![image-20250917101528392](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250917101528392.png)

![image-20250917102651175](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250917102651175.png)

å‚æ•°è®¾ç½®ï¼š

![image-20250917111834708](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250917111834708.png)



## æ‰¹é‡è·‘flowï¼š

![image-20250916201832427](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250916201832427.png)

æ¯ä¸ªå­æ–‡ä»¶é‡Œé¢ç”Ÿæˆ.tclæ–‡ä»¶å†è¿è¡Œ

å…·ä½“å¯ä»¥å‚è€ƒodsæ–‡ä»¶è¾“å‡º

```shell
#!/bin/bash

SRC_DIR=$(dirname "$(readlink -f "$0")")/src
RESULT_DIR="$(pwd)/result"
DEVICE="EC9H200-FHG676-8IMN-ED"
ODS_CONSOLE="/proj/ods_console.sh"

declare -A V_FILES
declare -A SDC_FILES
declare -a PRJ_NAMES

mkdir -p "$RESULT_DIR"

for top_dir in "$SRC_DIR"/*/; do
    prj=$(basename "$top_dir")
    PRJ_NAMES+=("$prj")

    V_FILES[$prj]=$(find "$top_dir" -type d -name "ori" -exec find {} -type f -name "*.v" \; | xargs)
    SDC_FILES[$prj]=$(find "$top_dir" -type d -name "ori" -exec find {} -type f -name "*.sdc" \; | xargs)

    TCL_FILE="$top_dir/run.tcl"
    echo "# Auto-generated run.tcl for $prj" > "$TCL_FILE"
    echo "create_project -device $DEVICE $prj \"$top_dir\"" >> "$TCL_FILE"
    echo "import_files -filelist Sources_1 { ${V_FILES[$prj]} }" >> "$TCL_FILE"
    echo "import_files -filelist Constraints_1 { ${SDC_FILES[$prj]} }" >> "$TCL_FILE"

    PRJ_RESULT_DIR="$RESULT_DIR/$prj"
    mkdir -p "$PRJ_RESULT_DIR"

    # è¿™é‡ŒæŒ‡å®š run_flows è¾“å‡ºç›®å½•
    echo "run_flows -dir \"$PRJ_RESULT_DIR\" synth_1" >> "$TCL_FILE"

    echo "Generated $TCL_FILE"
done

# ç”Ÿæˆ run_all.sh
RUN_ALL="$(pwd)/run_all.sh"
echo "#!/bin/bash" > $RUN_ALL
echo "# Auto-generated script to run all projects" >> $RUN_ALL
echo "" >> $RUN_ALL

for prj in "${PRJ_NAMES[@]}"; do
    TCL_FILE="$(realpath "$SRC_DIR/$prj/run.tcl")"
    echo "busb -Is -q sw_normal -n 4 -M 60000 sh \"$ODS_CONSOLE\" \"$TCL_FILE\"" >> $RUN_ALL
done

chmod +x $RUN_ALL
echo "run_all.sh å·²ç”Ÿæˆåœ¨å½“å‰ç›®å½•ï¼Œå¯é¡ºåºæ‰§è¡Œæ‰€æœ‰é¡¹ç›®çš„ tcl æ–‡ä»¶ã€‚"
```



![image-20250918203940944](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250918203940944.png)

â€œ1 hostâ€ è¡¨ç¤º **åœ¨ä¸€å°ä¸»æœºä¸Šåªèƒ½åŒæ—¶è¿è¡Œ 1 ä¸ªä»»åŠ¡**ï¼Œæ‰€ä»¥ç¬¬äºŒä¸ªä»»åŠ¡å°±æŒ‚åœ¨ PENDï¼Œç­‰å¾…ç¬¬ä¸€ä¸ªä»»åŠ¡ç»“æŸé‡Šæ”¾èµ„æºã€‚

è”ç³»é›†ç¾¤ç®¡ç†å‘˜è°ƒæ•´é˜Ÿåˆ—æˆ–ç”¨æˆ·é™åˆ¶

```
bjobs -l -u pydu
bkill 
```

è¿™æ ·å°±åªä¼šæ˜¾ç¤ºä½ è‡ªå·±æäº¤çš„ä»»åŠ¡çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬ PEND åŸå› ã€èµ„æºè¯·æ±‚ã€æ‰§è¡Œä¸»æœºç­‰ï¼Œä¸ä¼šæ˜¾ç¤ºåˆ«äººçš„ä»»åŠ¡ã€‚



## tclè„šæœ¬ï¼š

run.sh

![image-20250917123055024](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250917123055024.png)

![image-20250917143651430](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250917143651430.png)

ç”¨æ¥æ‰§è¡Œmain.pyä»¥åŠç¡®å®šcaselibDirè·¯å¾„ï¼ˆECCAD_HOMEå’Œoutput_pathä»¥åŠRELEASE_HOMEè¦è‡ªå·±å®šä¹‰ï¼‰

```shell
${srcDir}/main.py -t $caselibDir/macro/ -d $output_path/macro -tl 36000 -f $caselibDir/tcl_script/EC3H200.tcl -l $caselibDir/macro.txt -b 1 -dist
```

![image-20250917144526018](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250917144526018.png)

caselibDiré‡Œé¢æœ‰macro.txtå­˜æ”¾è¦è·‘çš„æ‰€æœ‰é¡¹ç›®å

![image-20250917144638874](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250917144638874.png)

ä¸“é—¨çš„tcl_scriptæ–‡ä»¶å¤¹å­˜æ”¾è¦è·‘çš„tclæ–‡ä»¶ï¼ˆè¿™é‡Œçš„tclæ‰æ˜¯æ¯ä¸ªé¡¹ç›®çœŸæ­£è·‘çš„odsï¼‰

![image-20250917144714075](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250917144714075.png)



## DRCæµ‹è¯•ï¼š

ç›´æ¥ç”¨ tcl ç”Ÿæˆç½‘è¡¨åç›´æ¥æµ‹è¯•



## ä¿å­˜çš„æ–‡ä»¶ï¼š

![image-20251009154955186](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20251009154955186.png)



## é—®é¢˜å•è´Ÿè´£äººï¼š

![image-20250928111655959](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250928111655959.png)

å¼ æ›¦æ³½





## å·¥ä½œè®°å½•ï¼š

1.  DSP IP æ ¸ç§»æ¤
2.  DRC æµ‹è¯•ç”¨ä¾‹æ„å»º
3.  Vivadoç”¨ä¾‹ç§»æ¤



## éœ€è¦å®Œæˆçš„å·¥ä½œï¼š

-   [x] windows DRCæµç¨‹
-   [ ] DRC é—®é¢˜å•ï¼Œå¡«è¡¨
-   [ ] è¿™ä¸ªDRCç”¨ä¾‹

![image-20251022100756158](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20251022100756158.png)

-   [ ] è¿™ä¸¤ä¸ªDRCç”¨ä¾‹

![image-20251022100829994](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20251022100829994.png)

ILSERDESè§£å†³äº†ï¼ŒIDSERDESè·‘ä¸é€šè¿˜æ˜¯





# æŠ¥é”™è®°å½•ï¼š

## no valid blockï¼š

åŸå› ï¼šcasç«¯å£æ²¡æœ‰æ¥ä¸Šï¼ˆcas_in å’Œ cas_out å¯¹æ¥ï¼Œp_out æ˜¯å•ç‹¬çš„è¾“å‡ºï¼‰

![image-20250923110418841](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923110418841.png)

![image-20250923111338454](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923111338454.png)



## macro placement failsï¼š

![image-20250923160247556](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923160247556.png)

bramçš„ä¾‹åŒ–æ—¶å‚æ•°å¿…é¡»æŒ‰ç…§è®¾å®šçš„æ¥ï¼Œ32/64ä¹‹ç±»çš„ä¸èƒ½éšä¾¿è®¾å®š



## é¿å…ä¼˜åŒ–é—®é¢˜ï¼š

![image-20250928112843523](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250928112843523.png)



# ysyxï¼š

## Scala

==**åˆ›å»ºå˜é‡ var å¸¸é‡ val**==

ä¸éœ€è¦å†™ ;

==**if è¡¨è¾¾å¼æœ‰è¿”å›å€¼ï¼š**==

```scala
val likelyCharactersSet = if (alphabet.length == 26)
    "english"
else 
    "not english"

println(likelyCharactersSet)
```

==**å‡½æ•°å®šä¹‰ï¼šdef**==

```scala
def times2(x: Int): Int = 2 * x		// å‚æ•°ä¸ºxï¼ˆå…¶ç±»å‹ä¸ºIntï¼‰ï¼Œè¿”å›å€¼ä¹Ÿæ˜¯Int

def distance(x: Int, y: Int, returnPositive: Boolean): Int = {
    val xy = x * y
    if (returnPositive) xy.abs else -xy.abs
}
```

å‡½æ•°è°ƒç”¨æ—¶å¯ä»¥å†™ä¸Šå‚æ•°åç±»ä¼¼verilogï¼š

```scala
def myMethod(count: Int, wrap: Boolean, wrapValue: Int = 24): Unit = { ... }

myMethod(wrapValue = 23, wrap = false, count = 10) //å¯ä»¥æ‰“ä¹±é¡ºåº
myMethod(wrap = false, count = 10) //é»˜è®¤wrapValueä¸º24
```

==**é‡è½½å‡½æ•°ï¼š**==

```scala
def times2(x: Int): Int = 2 * x
def times2(x: String): Int = 2 * x.toInt

times2(5)
times2("7")
```

==**åŒ¿åå‡½æ•°ï¼š**==

```scala
val intList = List(1, 2, 3)
val stringList = intList.map { i =>	// è°ƒç”¨äº†Listé‡Œçš„mapå‡½æ•°è½¬åŒ–Listé‡Œå˜é‡ä¸ºstring
  i.toString
}
```

![image-20250923172722466](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923172722466.png)

==**é€’å½’åŠå‡½æ•°å†…å®šä¹‰å‡½æ•°ï¼š**==

```scala
def asciiTriangle(rows: Int) {
    
    // multiplying "X" makes a string with many copies of "X"
    def printRow(columns: Int): Unit = println("X" * columns)
    
    if(rows > 0) {
        printRow(rows)
        asciiTriangle(rows - 1) // Here is the recursive call
    }
}

asciiTriangle(6)
```

![image-20250923161221762](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923161221762.png)

==**é“¾è¡¨listï¼š**==

```scala
val x = 7
val y = 14
val list1 = List(1, 2, 3)
val list2 = x :: y :: y :: Nil       // An alternate notation for assembling a list

val list3 = list1 ++ list2           // Appends the second list to the first list
val m = list2.length
val s = list2.size

val headOfList = list1.head          // Gets the first element of the list
val restOfList = list1.tail          // Get a new list with first element removed

val third = list1(2)                 // Gets the third element of a list (0-indexed)
```

![image-20250923161612307](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923161612307.png)

==**forå¾ªç¯ï¼š**==

```
for (i <- 0 to 7) { print(i + " ") }
```

![image-20250923162204298](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923162204298.png)

æŠŠ to æ”¹ä¸º until ï¼š

```
for (i <- 0 until 7) { print(i + " ") }
```

![image-20250923162314381](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923162314381.png)

æ­¥é•¿ç”¨ byï¼š

```
for(i <- 0 to 10 by 2) { print(i + " ") }
```

![image-20250923162357094](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923162357094.png)

éå† list å…ƒç´ ï¼š

```scala
val randomList = List(scala.util.Random.nextInt(), scala.util.Random.nextInt(), scala.util.Random.nextInt(), scala.util.Random.nextInt())
var listSum = 0
for (value <- randomList) {
  listSum += value
}
println("sum is " + listSum)
```

![image-20250923162640795](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250923162640795.png)

==**å¼•ç”¨å’Œæ‰“åŒ…æ–‡ä»¶ï¼š**==

```scala
package mytools
class Tool1 { ... }

import mytools.Tool1
```

å¸¸ç”¨æ–‡ä»¶ï¼š

```scala
import chisel3._
import chisel3.iotesters.{ChiselFlatSpec, Driver, PeekPokeTester}
```

\_è¡¨ç¤ºåŒ¹é…æ‰€æœ‰chisel3 packageé‡Œé¢çš„ classes å’Œ methods

==**classç±»ï¼š**==

```scala
class WrapCounter(counterBits: Int) {

  val max: Long = (1 << counterBits) - 1	//å£°æ˜ä¸ºLongç±»å‹ï¼Œåˆå§‹åŒ–ä¸º2^counterBitsï¼ˆ1å·¦ç§»counterBitsä½ï¼‰-1ï¼ˆæœ€å¤§æ•°ï¼‰
  var counter = 0L	//åˆå§‹åŒ–ä¸º0(ç±»å‹ä¸ºlong)
    
  def inc(): Long = {	//æ— å‚ï¼Œè¿”å›Longç±»å‹å€¼
    counter = counter + 1
    if (counter > max) {
        counter = 0
    }
    counter	//å……å½“è¿”å›å€¼
  }
  println(s"counter created with max value $max")	//æ‰“å°stringï¼ˆclassçš„ä¸€éƒ¨åˆ†ï¼Œæ¯æ¬¡åˆ›å»ºclassçš„æ—¶å€™éƒ½ä¼šæ‰“å°
}
```

==ä»£ç å—çš„æœ€åä¸€è¡Œä¼šè¢«ä½œä¸ºå½“å‰ä»£ç å—çš„è¿”å›å€¼==ï¼ˆå¦‚æœæ²¡æœ‰ï¼Œä¼šè¿”å›Unitï¼‰

è°ƒç”¨classç±»ï¼š

```scala
val x = new WrapCounter(2)	

x.inc() // Increments the counter

// æˆå‘˜å˜é‡é»˜è®¤ä¸ºpublic
if(x.counter == x.max) {              
    println("counter is about to wrap")
}

x inc() // å¯ä»¥çœç•¥.
```



## Chisel

å…¨ç¨‹ï¼šCounstructing Hardware In a Scala Embedded Language

### ç»„åˆç”µè·¯

==**åˆ›å»ºModuleï¼š**==

```scala
class Passthrough extends Module {	// Moduleæ˜¯Chiselé‡Œé¢æ„å»ºå¥½çš„Classï¼Œæ‰€æœ‰ç¡¬ä»¶æ¨¡å—éƒ½éœ€è¦extends
  val io = IO(new Bundle {	// Bundleï¼ˆæ†ï¼‰å£°æ˜ä¸€ä¸ªç»“æ„ä½“struct
    val in = Input(UInt(4.W))		//å£°æ˜ä¿¡å·æ–¹å‘
    val out = Output(UInt(4.W))		//UInt(4.W):è¡¨ç¤ºä¸ºUnsigned Integer of width 4
  })
  io.out := io.in	//:=è¡¨ç¤ºå³è¾¹ä¿¡å·é©±åŠ¨å·¦è¾¹ä¿¡å·
}
```

æŠŠchiselçš„moduleè½¬åŒ–ä¸ºçœŸæ­£çš„verilog moduleï¼šï¼ˆelaborationï¼šé˜è¿°ï¼‰

```scala
println(getVerilog(new Passthrough))	//printlnä¼šæ‰“å°å‡ºæ¥ç»“æœ
```

![image-20250924100310334](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250924100310334.png)

==**æ“ä½œç¬¦ï¼š**==

```scala
class MyOperators extends Module {
  val io = IO(new Bundle {
    val in      = Input(UInt(4.W))
    val out_add = Output(UInt(4.W))
    val out_sub = Output(UInt(4.W))
    val out_mul = Output(UInt(4.W))
  })

  io.out_add := 1.U + 4.U	//è‡ªåŠ¨æ ¹æ®æ•°å€¼ï¼Œè¯†åˆ«æ‰€éœ€ä½å®½
  io.out_sub := 2.U - 1.U
  io.out_mul := 4.U * 2.U
}
println(getVerilog(new MyOperators))
```

![image-20250924105823169](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250924105823169.png)

ä¼šæ ¹æ®ä½å®½è‡ªåŠ¨è¡¥0

==**Muxï¼šä¸‰å…ƒé€‰æ‹©**==

==**Catï¼šæ‹¼æ¥**==

```scala
class MyOperatorsTwo extends Module {
  val io = IO(new Bundle {
    val in      = Input(UInt(4.W))
    val out_mux = Output(UInt(4.W))
    val out_cat = Output(UInt(4.W))
  })

  val s = true.B	// Bä»£è¡¨ bool
  io.out_mux := Mux(s, 3.U, 0.U) // should return 3.U, since s is true
  io.out_cat := Cat(2.U, 1.U)    // concatenates 2 (b10) with 1 (b1) to give 5 (101)
}

println(getVerilog(new MyOperatorsTwo))

test(new MyOperatorsTwo) { c =>
  c.io.out_mux.expect(3.U)
  c.io.out_cat.expect(5.U)
}
println("SUCCESS!!")
```

![image-20250924110511382](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250924110511382.png)

FIFOä»²è£å™¨ä¾‹å­ï¼š

![image-20250924113427290](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250924113427290.png)

```scala
class Arbiter extends Module {
  val io = IO(new Bundle {
    // FIFO
    val fifo_valid = Input(Bool())
    val fifo_ready = Output(Bool())
    val fifo_data  = Input(UInt(16.W))
    
    // PE0
    val pe0_valid  = Output(Bool())
    val pe0_ready  = Input(Bool())
    val pe0_data   = Output(UInt(16.W))
    
    // PE1
    val pe1_valid  = Output(Bool())
    val pe1_ready  = Input(Bool())
    val pe1_data   = Output(UInt(16.W))
  })

    io.fifo_ready := io.pe0_ready || io.pe1_ready	//æ ¹æ®inputæ¥å†³å®šoutput
    io.pe0_valid := io.fifo_valid && io.pe0_ready
    io.pe1_valid := io.fifo_valid && io.pe1_ready && !io.pe0_ready
    io.pe0_data := io.fifo_data
    io.pe1_data := io.fifo_data
}

test(new Arbiter) { c =>
  import scala.util.Random
  val data = Random.nextInt(65536)
  c.io.fifo_data.poke(data.U)
  
  for (i <- 0 until 8) {
    //(i >> n) % 2 å°±æ˜¯å– i çš„ç¬¬ n ä½
    c.io.fifo_valid.poke((((i >> 0) % 2) != 0).B)	//1ï¼Œ3ï¼Œ5ï¼Œ7
    c.io.pe0_ready.poke((((i >> 1) % 2) != 0).B)	//å–içš„ç¬¬2ä½ï¼š2ï¼Œ3ï¼Œ6ï¼Œ7
    c.io.pe1_ready.poke((((i >> 2) % 2) != 0).B)	//4ï¼Œ5ï¼Œ6ï¼Œ7

    c.io.fifo_ready.expect((i > 1).B)
    c.io.pe0_valid.expect((i == 3 || i == 7).B)
    c.io.pe1_valid.expect((i == 5).B)
    
    if (i == 3 || i ==7) {
      c.io.pe0_data.expect((data).U)
    } else if (i == 5) {
      c.io.pe1_data.expect((data).U)
    }
  }
}
println("SUCCESS!!")
```

==**+& è¿ç®—ç¬¦**==

```scala
class ParameterizedAdder(saturate: Boolean) extends Module {
  val io = IO(new Bundle {
    val in_a = Input(UInt(4.W))
    val in_b = Input(UInt(4.W))
    val out  = Output(UInt(4.W))
  })

  val sum = io.in_a +& io.in_b	//ç›´æ¥åŠ çš„è¯ä¼šæˆªæ–­ä¸º4ä½ï¼Œç”¨+&å°±å¯ä»¥æ­£å¸¸å¾—åˆ°5ä½ç»“æœ
  if(saturate){
      io.out := Mux(sum > 15.U, 15.U, sum)
  }else{
      io.out := sum
  }
}

for (saturate <- Seq(true, false)) {
  test(new ParameterizedAdder(saturate)) { c =>
    // 100 random tests
    val cycles = 100
    import scala.util.Random
    import scala.math.min
    for (i <- 0 until cycles) {
      val in_a = Random.nextInt(16)
      val in_b = Random.nextInt(16)
      c.io.in_a.poke(in_a.U)
      c.io.in_b.poke(in_b.U)
      if (saturate) {
        c.io.out.expect(min(in_a + in_b, 15).U)
      } else {
        c.io.out.expect(((in_a + in_b) % 16).U)
      }
    }
    
    // ensure we test saturation vs. truncation
    c.io.in_a.poke(15.U)
    c.io.in_b.poke(15.U)
    if (saturate) {
      c.io.out.expect(15.U)
    } else {
      c.io.out.expect(14.U)
    }
  }
}
println("SUCCESS!!")
```

==**èµ‹å€¼è¦†ç›–**==

```scala
class LastConnect extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(4.W))
    val out = Output(UInt(4.W))
  })
  io.out := 1.U
  io.out := 2.U
  io.out := 3.U
  io.out := 4.U	//æœ€åä¸€æ¬¡èµ‹å€¼çš„å€¼-> io=4
}

//  Test LastConnect
test(new LastConnect) { c => c.io.out.expect(4.U) } // Assert that the output correctly has 4
println("SUCCESS!!") // Scala Code: if we get here, our tests passed!
```

==**æ¡ä»¶è¯­å¥**==

when, elsewhen, otherwise:(æœ‰ä¸ª.elsewhen .otherwise)

ä¸åŒäº scala çš„ if è¯­å¥ï¼Œchisel çš„ when è¯­å¥æ²¡æœ‰è¿”å›å€¼ï¼š

ä¸èƒ½è¿™æ ·ä½¿ç”¨ val result = when(squareIt) { x * x }.otherwise { x }

```scala
// Max3 returns the max of its 3 arguments
class Max3 extends Module {
  val io = IO(new Bundle {
    val in1 = Input(UInt(16.W))
    val in2 = Input(UInt(16.W))
    val in3 = Input(UInt(16.W))
    val out = Output(UInt(16.W))
  })
    
  when(io.in1 >= io.in2 && io.in1 >= io.in3) {
    io.out := io.in1  
  }.elsewhen(io.in2 >= io.in3) {
    io.out := io.in2 
  }.otherwise {
    io.out := io.in3
  }
}

// Test Max3
test(new Max3) { c =>
  // verify that the max of the three inputs is correct
  c.io.in1.poke(6.U)
  c.io.in2.poke(4.U)
  c.io.in3.poke(2.U)
  c.io.out.expect(6.U)  // input 1 should be biggest
}

println("SUCCESS!!") // Scala Code: if we get here, our tests passed!
```

```scala
when(io.select === 0.U){	//æ¡ä»¶åˆ¤æ–­ç›¸ç­‰ ===ï¼ˆä¸‰ä¸ª=ï¼‰
  result := (square - (2.S * io.x)) + 1.S
}.elsewhen(io.select === 1.U){
  result := (2.S * square) + (6.S * io.x) + 3.S
}.otherwise{
  result := (4.S * square) - (10.S * io.x) - 5.S
}
```



==**Wire**==

wire å‡ºç°åœ¨ := çš„å·¦å³éƒ½å¯ä»¥

```scala
val row10 = Wire(UInt(16.W))
row10 := io.in0 
row20 := row10
```



==**çŠ¶æ€æœº**==

![image-20250928190703365](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250928190703365.png)

```scala
// state map
def states = Map("idle" -> 0, "coding" -> 1, "writing" -> 2, "grad" -> 3)	//å®šä¹‰æ˜ å°„ï¼Œå­—ç¬¦ä¸²å¯¹åº” Int æ•°å€¼

// å‡½æ•°å®šä¹‰
def gradLife (state: Int, coffee: Boolean, idea: Boolean, pressure: Boolean): Int = {
  var nextState = states("idle")
   if (state == states("idle")) {
    if      (coffee) { nextState = states("coding") }
    else if (idea) { nextState = states("idle") }
    else if (pressure) { nextState = states("writing") }
  } else if (state == states("coding")) {
    if      (coffee) { nextState = states("coding") } 
    else if (idea || pressure) { nextState = states("writing") }
  } else if (state == states("writing")) {
    if      (coffee || idea) { nextState = states("writing") }
    else if (pressure) { nextState = states("grad") }
  }
  nextState
}

// some sanity checks
(0 until states.size).foreach{ state => assert(gradLife(state, false, false, false) == states("idle")) }
assert(gradLife(states("writing"), true, false, true) == states("writing"))
assert(gradLife(states("idle"), true, true, true) == states("coding"))
assert(gradLife(states("idle"), false, true, true) == states("idle"))
assert(gradLife(states("grad"), false, false, false) == states("idle"))

//chisel ç±»å®ç°
class GradLife extends Module {
  val io = IO(new Bundle {
    val state = Input(UInt(2.W))
    val coffee = Input(Bool())
    val idea = Input(Bool())
    val pressure = Input(Bool())
    val nextState = Output(UInt(2.W))
  })
    
  val idle :: coding :: writing :: grad :: Nil = Enum(4)	//Enumï¼ˆ4ï¼‰ 0ï¼Œ1ï¼Œ2ï¼Œ3
  
  io.nextState := idle
  when (io.state === idle) {
    when      (io.coffee) { io.nextState := coding } 
    .elsewhen (io.idea) { io.nextState := idle }
    .elsewhen (io.pressure) { io.nextState := writing }
  } .elsewhen (io.state === coding) {
    when      (io.coffee) { io.nextState := coding } 
    .elsewhen (io.idea || io.pressure) { io.nextState := writing }
  } .elsewhen (io.state === writing) {
    when      (io.coffee || io.idea) { io.nextState := writing }
    .elsewhen (io.pressure) { io.nextState := grad }
  }
}


// Test
test(new GradLife) { c =>
  for (state <- 0 to 3) {	//åˆå§‹çŠ¶æ€éšæœºé€‰æ‹© 0-3
    for (coffee <- List(true, false)) {	//ç”¨Listæ¥éå†æ‰€æœ‰æƒ…å†µ
      for (idea <- List(true, false)) {
        for (pressure <- List(true, false)) {
          c.io.state.poke(state.U)
          c.io.coffee.poke(coffee.B)
          c.io.idea.poke(idea.B)
          c.io.pressure.poke(pressure.B)
          c.io.nextState.expect(gradLife(state, coffee, idea, pressure).U)	//è°ƒç”¨å‡½æ•°è¿›è¡Œæ£€æŸ¥
        }
      }
    }
  }
}
println("SUCCESS!!") // Scala Code: if we get here, our tests passed!
```



### æ—¶åºç”µè·¯

==**Reg**==

```scala
Reg(type)
```

```scala
class RegisterModule extends Module {
  val io = IO(new Bundle {
    val in  = Input(UInt(12.W))
    val out = Output(UInt(12.W))
  })
  
  val register = Reg(UInt(12.W))	//Regå®šä¹‰
  register := io.in + 1.U
  io.out := register
}

test(new RegisterModule) { c =>
  for (i <- 0 until 100) {
    c.io.in.poke(i.U)
    c.clock.step(1)		//chiselé‡Œé¢çš„Moduleéƒ½éšå«ä¸€ä¸ªæ—¶é’Ÿclockï¼Œè¿™æ ·ä¸ç”¨æ¯æ¬¡éƒ½ä¾‹åŒ–clock
    c.io.out.expect((i + 1).U)
  }
}
println("SUCCESS!!")
```

å¯¹åº”ç”Ÿæˆverilogä»£ç ï¼š

![image-20250929101627434](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250929101627434.png)

ç»„åˆé€»è¾‘ç”µè·¯æ²¡æœ‰å¯„å­˜å™¨ï¼Œ`io.out` ä¼šç«‹å³ç­‰äº `io.in+1`ï¼Œä¸ä¾èµ–æ—¶é’Ÿã€‚æµ‹è¯•ä¹Ÿå°±ä¸ç”¨ `step(1)`ï¼Œç›´æ¥ `poke` åç«‹åˆ» `expect` å°±èƒ½æ£€æŸ¥ã€‚**æ—¶åºé€»è¾‘ï¼ˆå¯„å­˜å™¨ï¼‰â†’ å¿…é¡»ç­‰æ—¶é’Ÿè§¦å‘æ‰æ›´æ–°ï¼ˆè¦ç”¨ clock.step(1)ï¼šç›¸å½“äºç­‰ä¸€ä¸ªæ—¶é’Ÿæ²¿)**

==**ç±»å‹ï¼ˆtypeï¼‰** å’Œ **ç¡¬ä»¶èŠ‚ç‚¹ï¼ˆnodeï¼‰** çš„åŒºåˆ«==

-   `UInt(2.W)`ï¼šè¿™é‡Œæ˜¯**ä¸€ä¸ªç±»å‹è¯´æ˜**ï¼Œæ„æ€æ˜¯â€œä¸€ä¸ª 2 ä½å®½çš„æ— ç¬¦å·æ•´æ•°ç±»å‹â€ã€‚å®ƒåªæ˜¯è“å›¾ï¼Œæ²¡æœ‰å…·ä½“çš„å€¼ã€‚`Reg(UInt(2.W))` å°±æ˜¯å£°æ˜ä¸€ä¸ªå¯„å­˜å™¨ï¼Œè¿™ä¸ªå¯„å­˜å™¨å­˜æ”¾çš„ä¸œè¥¿æ˜¯ 2 ä½æ— ç¬¦å·æ•°ã€‚
-   `2.U`ï¼šè¿™æ˜¯**ä¸€ä¸ªç¡¬ä»¶å¸¸é‡èŠ‚ç‚¹**ï¼Œæ„æ€æ˜¯ç”µè·¯ä¸­å›ºå®šå¸¸æ•°â€œ2â€ã€‚å®ƒå·²ç»æ˜¯å®é™…çš„ç”µè·¯å€¼ï¼Œè€Œä¸æ˜¯ç±»å‹ã€‚

```
val myReg = Reg(UInt(2.W))   // âœ… æ­£ç¡®ï¼šReg éœ€è¦ç±»å‹ä½œä¸ºæ¨¡æ¿
val myReg = Reg(2.U)         // âŒ é”™è¯¯ï¼šä½ ä¼ çš„æ˜¯ä¸€ä¸ªå¸¸é‡å€¼èŠ‚ç‚¹ï¼Œä¸æ˜¯ç±»å‹
```



==**RegNext**==

**ä¸éœ€è¦æ˜¾ç¤ºå£°æ˜regåå­—åŠä½å®½**

ç”¨æ¥**æŠŠä¿¡å·å»¶è¿Ÿä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸ**ã€‚

åŸºæœ¬ç”¨æ³•ï¼š

```scala
val reg = RegNext(data_in)        // ä¸‹ä¸€æ‹è¾“å‡º = æœ¬æ‹è¾“å…¥
val reg_init = RegNext(data_in, 0.U) // å¸¦åˆå§‹å€¼ï¼Œå¤ä½æ—¶è¾“å‡º 0
```

è§£é‡Šï¼š

-   `RegNext(x)`ï¼šåˆ›å»ºä¸€ä¸ªå¯„å­˜å™¨ï¼Œå­˜å‚¨ `x` çš„å½“å‰å€¼ï¼Œåœ¨**ä¸‹ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸ**è¾“å‡ºã€‚
-   `RegNext(x, init)`ï¼šåŒä¸Šï¼Œä½†åœ¨å¤ä½æ—¶å¯„å­˜å™¨è¾“å‡º `init`ã€‚
-   å¸¸ç”¨äºä¿¡å·æ‰“æ‹ã€ç§»ä½å¯„å­˜ã€æ—¶åºå¯¹é½ã€‚

ä¾‹å¦‚ï¼š

```scala
val a = io.in
val b = RegNext(a)  // b æ¯” a æ™šä¸€æ‹
```

```scala
class RegNextModule extends Module {
  val io = IO(new Bundle {
    val in  = Input(UInt(12.W))
    val out = Output(UInt(12.W))
  })
  
  io.out := RegNext(io.in + 1.U)	//è‡ªåŠ¨å¸®ä½ å–åå’Œæ¨æ–­ä½å®½
}

test(new RegNextModule) { c =>
  for (i <- 0 until 100) {
    c.io.in.poke(i.U)
    c.clock.step(1)
    c.io.out.expect((i + 1).U)
  }
}
println("SUCCESS!!")
```

![image-20250929102105113](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250929102105113.png)



==**RegInit**==

Regåˆ›å»ºæ—¶éšæœºåˆå§‹åŒ–ï¼Œä½¿ç”¨RegInitå¯ä»¥æŒ‡å®šåˆå§‹åŒ–å€¼

```scala
val myReg = RegInit(UInt(12.W), 0.U)	//ä¸¤ç§æ–¹å¼éƒ½å¯ä»¥ï¼Œåˆå§‹åŒ–ä¸º0
val myReg = RegInit(0.U(12.W))
```

ä½¿ç”¨RegInitåˆå§‹åŒ–åçš„verilogä»£ç ï¼š

![image-20250929103350788](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250929103350788.png)

å¤šäº†ä¸€ä¸ª if (reset)ï¼›å’Œclockä¸€æ ·ä¹Ÿæ˜¯**éšå«çš„ä¿¡å·ç«¯å£ï¼ˆé«˜ç”µå¹³æœ‰æ•ˆï¼ŒåŒæ­¥å¤ä½ï¼‰**

åœ¨resetä¹‹å‰è¿˜æ˜¯è¢«éšæœºåˆå§‹åŒ–ï¼ŒPeekPokeTestersæ€»æ˜¯åœ¨æµ‹è¯•ä¹‹å‰å…ˆresetï¼Œä¹Ÿå¯ä»¥ç”¨**reset(n) å‡½æ•°æ‰‹åŠ¨reset nä¸ªæ—¶é’Ÿå‘¨æœŸ**



==**å·¦ç§»å¯„å­˜å™¨**==

```scala
class MyShiftRegister(val init: Int = 1) extends Module {	//è¾“å…¥æ•°æ®å‚æ•°é»˜è®¤åˆå§‹åŒ–ä¸º1ï¼ˆä¸Šç”µåçš„å€¼è€Œå·²ï¼‰
  val io = IO(new Bundle {
    val in  = Input(Bool())
    val out = Output(UInt(4.W))
  })

  val state = RegInit(UInt(4.W), init.U)

  val nextState = (state << 1) | io.in	//å·¦ç§»1ä½åï¼ŒæŒ‰ä½æˆ–ï¼ˆåªæˆ–1ä½ï¼šç›¸å½“äºæŠŠio.inç§»å…¥æœ€ä½ä½ï¼‰
  state := nextState
  io.out := state
}

test(new MyShiftRegister()) { c =>
  var state = c.init	//ä¼ å…¥è®¾ç½®çš„å‚æ•°
  for (i <- 0 until 10) {
    // poke in LSB of i (i % 2)
    c.io.in.poke(((i % 2) != 0).B)
    // update expected state
    state = ((state * 2) + (i % 2)) & 0xf
    c.clock.step(1)
    c.io.out.expect(state.U)
  }
}
println("SUCCESS!!")
```

**å¸¦å‚æ•°ç‰ˆæœ¬**

```scala
class MyOptionalShiftRegister(val n: Int, val init: BigInt = 1) extends Module {	// BigInt å¯ä»¥è¡¨ç¤ºä»»æ„å¤§å°çš„æ•´æ•°ï¼Œä¸ä¼šæº¢å‡º		
  val io = IO(new Bundle {
    val en  = Input(Bool())
    val in  = Input(Bool())
    val out = Output(UInt(n.W))
  })

  val state = RegInit(init.U(n.W))	//nä½å¯„å­˜å™¨

  val nextState = (state << 1) | io.in
  when (io.en) {
    state  := nextState
  }
  io.out := state
}

for (i <- Seq(3, 4, 8, 24, 65)) {	//æŒ¨ä¸ªæµ‹è¯•i=3ï¼Œ4ï¼Œ8...
  println(s"Testing n=$i")
  test(new MyOptionalShiftRegister(n = i)) { c =>	//ä½å®½èµ‹å€¼ n=i
    val inSeq = Seq(0, 1, 1, 1, 0, 1, 1, 0, 0, 1)
    var state = c.init
    var i = 0
    c.io.en.poke(true.B)
    while (i < 10 * c.n) {
      // poke in repeated inSeq
      val toPoke = inSeq(i % inSeq.length)
      c.io.in.poke((toPoke != 0).B)
      // update expected state
      state = ((state * 2) + toPoke) & BigInt("1"*c.n, 2)	//state * 2 â†’ å·¦ç§»ä¸€ä½ï¼ˆå¯¹åº”å¯„å­˜å™¨å·¦ç§»ï¼‰+ toPoke â†’ å°†æ–°è¾“å…¥ bit æ”¾åˆ°æœ€ä½ä½ & BigInt("1"*c.n, 2) â†’ åªä¿ç•™å¯„å­˜å™¨å®½åº¦ c.n çš„ä½ï¼Œé˜²æ­¢æº¢å‡º
      c.clock.step(1)
      c.io.out.expect(state.U)
      i += 1
    }
  }
}
println("SUCCESS!!")
```

```scala
BigInt("1"*c.n, 2)	
//åœ¨ Scala ä¸­ï¼Œ"1"*c.n ä¼šé‡å¤å­—ç¬¦ä¸² "1" å…± c.n æ¬¡, åé¢çš„ 2 è¡¨ç¤ºäºŒè¿›åˆ¶
//ä¾‹å¦‚ c.n = 4ï¼Œç»“æœå°±æ˜¯ "1111"
```

**å¯„å­˜å™¨å®½åº¦å¯èƒ½å¾ˆå¤§**

-   ç¡¬ä»¶å¯„å­˜å™¨å®½åº¦ `c.n` ä¸æ˜¯å›ºå®šçš„ 32 æˆ– 64 ä½
-   å¦‚æœç›´æ¥ç”¨ Scala çš„ `Int` æˆ– `Long` åšæ©ç ï¼Œä½æ•°è¶…è¿‡å®ƒä»¬çš„æœ€å¤§å®½åº¦å°±æº¢å‡ºäº†
-   `BigInt` æ”¯æŒä»»æ„ä½å®½ï¼Œæ‰€ä»¥å¯ä»¥å®‰å…¨è¡¨ç¤ºä»»æ„é•¿åº¦çš„å¯„å­˜å™¨æ©ç 



==**æ‰‹åŠ¨åˆ›å»º clk å’Œ rst**==

```scala
import chisel3.experimental.{withClock, withReset, withClockAndReset}	//éœ€è¦å…ˆimportä¾èµ–

class ClockExamples extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(10.W))
    val alternateReset    = Input(Bool())
    val alternateClock    = Input(Clock())
    val outImplicit       = Output(UInt())
    val outAlternateReset = Output(UInt())
    val outAlternateClock = Output(UInt())
    val outAlternateBoth  = Output(UInt())
  })

  val imp = RegInit(0.U(10.W))
  imp := io.in
  io.outImplicit := imp

  withReset(io.alternateReset) {	//æ—¶é’Ÿç›¸åŒï¼Œreset ä¸åŒ
    val altRst = RegInit(0.U(10.W))
    altRst := io.in
    io.outAlternateReset := altRst
  }

  withClock(io.alternateClock) {	//æ—¶é’Ÿä¸åŒ reset è¿˜æ˜¯é»˜è®¤
    val altClk = RegInit(0.U(10.W))
    altClk := io.in
    io.outAlternateClock := altClk
  }

  withClockAndReset(io.alternateClock, io.alternateReset) {	//æ—¶é’Ÿå’Œ resetéƒ½ä¸åŒ
    val alt = RegInit(0.U(10.W))
    alt := io.in
    io.outAlternateBoth := alt
  }
}

println(getVerilog(new ClockExamples))
```

![image-20250929185938950](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250929185938950.png)

![image-20250929185906191](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250929185906191.png)

![image-20250929185527998](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250929185527998.png)

==FIR æ»¤æ³¢å™¨==

```scala
class My4ElementFir(b0: Int, b1: Int, b2: Int, b3: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(8.W))
    val out = Output(UInt(8.W))
  })

  val x_n1 = RegNext(io.in, 0.U)
  val x_n2 = RegNext(x_n1, 0.U)
  val x_n3 = RegNext(x_n2, 0.U)
  io.out := io.in * b0.U(8.W) + 
    x_n1 * b1.U(8.W) +
    x_n2 * b2.U(8.W) + 
    x_n3 * b3.U(8.W)
}
```

è§£é‡Šå¦‚ä¸‹ï¼š

-   `b0`~`b3` æ˜¯æ»¤æ³¢å™¨ç³»æ•°ã€‚
-   `io.in` æ˜¯å½“å‰è¾“å…¥ï¼Œ`io.out` æ˜¯è¾“å‡ºã€‚
-   `x_n1`ã€`x_n2`ã€`x_n3` æ˜¯è¾“å…¥ä¿¡å·çš„ 1ã€2ã€3 ä¸ªæ—¶é’Ÿå‘¨æœŸå‰çš„å€¼ï¼Œç”¨ `RegNext` å®ç°ç§»ä½å¯„å­˜ã€‚
-   è¾“å‡ºæ˜¯ `å½“å‰è¾“å…¥ * b0 + å»¶è¿Ÿ1æ‹è¾“å…¥ * b1 + å»¶è¿Ÿ2æ‹è¾“å…¥ * b2 + å»¶è¿Ÿ3æ‹è¾“å…¥ * b3`ï¼Œå³ FIR å·ç§¯å’Œã€‚

å®ƒç›¸å½“äºå®ç°äº†
 `y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] + b3*x[n-3]`ã€‚



==æ³›å‹ã€æ¡æ‰‹æ¥å£==

```scala
class QueueModule[T <: Data](ioType: T, entries: Int) extends MultiIOModule {
  val in = IO(Flipped(Decoupled(ioType)))	//ç¿»è½¬å in_validä¸ºè¾“å…¥ï¼Œin_readyä¸ºè¾“å‡º
  val out = IO(Decoupled(ioType))	//æœªç¿»è½¬ï¼Œout_readyä¸ºè¾“å…¥ï¼Œout_validä¸ºè¾“å‡º
  out <> Queue(in, entries)	//è¿æ¥ + FIFO é˜Ÿåˆ—å®ä¾‹åŒ–
}
```

![image-20251009192150324](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20251009192150324.png)

`T <: Data` æ˜¯ **Scala æ³›å‹ä¸­çš„ç±»å‹ä¸Šç•Œ**ï¼ˆupper boundï¼‰ç”¨æ³•ã€‚

è§£é‡Šï¼š

-   `T` æ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹å‚æ•°ï¼Œè¡¨ç¤ºæ¨¡å—å¯ä»¥å¤„ç†ä»»æ„ç±»å‹çš„æ•°æ®ã€‚
-   `<: Data` è¡¨ç¤º `T` å¿…é¡»æ˜¯ `Data` çš„å­ç±»æˆ–è‡ªèº«ï¼ˆåœ¨ Chisel ä¸­ï¼Œ`Data` æ˜¯æ‰€æœ‰ç¡¬ä»¶ç±»å‹çš„åŸºç±»ï¼Œæ¯”å¦‚ `UInt`ã€`SInt`ã€`Bundle` ç­‰ï¼‰ã€‚
-   ä½œç”¨ï¼šä¿è¯æ³›å‹æ¨¡å—åªèƒ½ç”¨ Chisel çš„ç¡¬ä»¶æ•°æ®ç±»å‹ï¼Œè€Œä¸èƒ½ç”¨æ™®é€š Scala ç±»å‹ã€‚

ä¾‹å­ï¼š

```scala
def foo[T <: Data](x: T): T = x
// x å¯ä»¥æ˜¯ UIntã€SIntã€Bundle ç­‰ï¼Œä½†ä¸èƒ½æ˜¯ Intã€String ç­‰æ™®é€šç±»å‹
```

**Decoupled** æ˜¯ Chisel æä¾›çš„ **æ¡æ‰‹æ¥å£æ¨¡æ¿**ï¼Œç”¨äºåœ¨æ¨¡å—é—´ä¼ é€’æ•°æ®æ—¶æ§åˆ¶æµï¼š

`Decoupled(ioType)` ä¼šç”Ÿæˆä¸€ä¸ª `Bundle`ï¼ŒåŒ…å«ä¸‰ä¸ªå­—æ®µï¼š

```scala
class DecoupledIO[T <: Data](gen: T) extends Bundle {
  val bits  = gen         // ä¼ è¾“çš„æ•°æ®ï¼Œç±»å‹ä¸º ioType
  val valid = Output(Bool()) // å‘é€ç«¯è¾“å‡ºï¼Œé«˜è¡¨ç¤ºæ•°æ®æœ‰æ•ˆ
  val ready = Input(Bool())  // æ¥æ”¶ç«¯è¾“å…¥ï¼Œé«˜è¡¨ç¤ºå‡†å¤‡å¥½æ¥æ”¶
}
```

`bits`ï¼šå®é™…ä¼ è¾“çš„æ•°æ®

`valid`ï¼šå‘é€ç«¯è¡¨ç¤ºæ•°æ®æœ‰æ•ˆ

`ready`ï¼šæ¥æ”¶ç«¯è¡¨ç¤ºå¯ä»¥æ¥æ”¶

**Decoupled æ¥å£æœ¬èº«é•¿ä»€ä¹ˆæ ·ï¼Ÿ**

`Decoupled(UInt(8.W))` å±•å¼€åæ˜¯ä¸€ä¸ª Bundleï¼š

```
val valid = Output(Bool())
val ready = Input(Bool())
val bits  = Output(UInt(8.W))
```

å®ƒè¡¨ç¤ºâ€œæ•°æ®ä»è¯¥ç«¯å£**æµå‡º**â€ã€‚
 ä¹Ÿå°±æ˜¯è¿™ä¸ªç«¯é»˜è®¤æ˜¯**ç”Ÿäº§è€…ï¼ˆè¾“å‡ºç«¯ï¼‰**ã€‚

**Flipped çš„ä½œç”¨ï¼š**
 åœ¨æ¨¡å—ç«¯å£é‡Œå†™ `Flipped(Decoupled(ioType))`ï¼š

-   ç¿»è½¬ä¿¡å·æ–¹å‘ï¼Œä½¿æ¨¡å—**ä½œä¸ºæ¶ˆè´¹è€…**æ¥æ¥æ”¶æ•°æ®ï¼š
    -   åŸæ¥ `Decoupled` çš„ `valid` æ˜¯è¾“å‡ºã€`ready` æ˜¯è¾“å…¥ï¼Œ
    -   ç¿»è½¬å `valid` æˆä¸ºæ¨¡å—è¾“å…¥ï¼Œ`ready` æˆä¸ºæ¨¡å—è¾“å‡ºã€‚

**out <> Queue(in, entries)** ï¼š

å¯ä»¥æ‹†è§£æˆä¸¤éƒ¨åˆ†ç†è§£ï¼š

1.  **`Queue(in, entries)`**

-   Chisel å†…ç½®å‡½æ•°ï¼Œç”Ÿæˆä¸€ä¸ª **æ·±åº¦ä¸º `entries` çš„ FIFO é˜Ÿåˆ—**ã€‚
-   è¾“å…¥æ˜¯ `Decoupled` æ¥å£ `in`ï¼ˆå¸¦ `bits/valid/ready`ï¼‰ã€‚
-   è¾“å‡ºæ˜¯ä¸€ä¸ªåŒç±»å‹çš„ `Decoupled` æ¥å£ï¼Œè‡ªåŠ¨å®ç° FIFO è¯»å†™ã€æŒ‡é’ˆç®¡ç†å’Œæ»¡/ç©ºåˆ¤æ–­ã€‚

1.  **`out <> ...`**

-   `<>` æ˜¯ Chisel çš„ **åŒå‘ç»‘å®šè¿ç®—ç¬¦**ï¼ˆbulk connectï¼‰ï¼š

    -   ä¼šæŠŠä¸¤è¾¹ç›¸åŒåå­—çš„ä¿¡å·ï¼ˆå¦‚ `bits`ã€`valid`ã€`ready`ï¼‰è‡ªåŠ¨äº’ç›¸è¿æ¥

    -   ç­‰ä»·äºï¼š

        ```
        out.bits := Queue(in, entries).bits
        Queue(in, entries).bits := out.bits // åŒå‘ç»‘å®š valid/ready
        out.valid := Queue(in, entries).valid
        Queue(in, entries).ready := out.ready
        ```

**æ€»ç»“**ï¼š

-   è¿™ä¸€è¡Œæ„æ€æ˜¯ï¼š**åˆ›å»ºä¸€ä¸ª FIFO é˜Ÿåˆ—ï¼ŒæŠŠè¾“å…¥ `in` çš„ `Decoupled` ä¿¡å·é€å…¥é˜Ÿåˆ—ï¼Œç„¶åæŠŠé˜Ÿåˆ—è¾“å‡ºç›´æ¥è¿æ¥åˆ° `out`**ã€‚
-   ç®€åŒ–äº†æ‰‹åŠ¨å†™å¯„å­˜å™¨æ•°ç»„ã€æŒ‡é’ˆå’Œæ¡æ‰‹é€»è¾‘çš„æ­¥éª¤ã€‚



==FIFOé˜Ÿåˆ—==

```verilog
module Queue(
  input        clock,
  input        reset,
  output       io_enq_ready,
  input        io_enq_valid,
  input  [8:0] io_enq_bits,
  input        io_deq_ready,
  output       io_deq_valid,
  output [8:0] io_deq_bits
);
  reg [8:0] ram [0:199]; // @[Decoupled.scala 218:16]
  wire [8:0] ram_io_deq_bits_MPORT_data; // @[Decoupled.scala 218:16]
  wire [7:0] ram_io_deq_bits_MPORT_addr; // @[Decoupled.scala 218:16]
  wire [8:0] ram_MPORT_data; // @[Decoupled.scala 218:16]
  wire [7:0] ram_MPORT_addr; // @[Decoupled.scala 218:16]
  wire  ram_MPORT_mask; // @[Decoupled.scala 218:16]
  wire  ram_MPORT_en; // @[Decoupled.scala 218:16]
  reg [7:0] value; // @[Counter.scala 60:40]
  reg [7:0] value_1; // @[Counter.scala 60:40]
  reg  maybe_full; // @[Decoupled.scala 221:27]
  wire  ptr_match = value == value_1; // @[Decoupled.scala 223:33]
  wire  empty = ptr_match & ~maybe_full; // @[Decoupled.scala 224:25]
  wire  full = ptr_match & maybe_full; // @[Decoupled.scala 225:24]
  wire  do_enq = io_enq_ready & io_enq_valid; // @[Decoupled.scala 40:37]
  wire  do_deq = io_deq_ready & io_deq_valid; // @[Decoupled.scala 40:37]
  wire  wrap = value == 8'hc7; // @[Counter.scala 72:24]
  wire [7:0] _value_T_1 = value + 8'h1; // @[Counter.scala 76:24]
  wire  wrap_1 = value_1 == 8'hc7; // @[Counter.scala 72:24]
  wire [7:0] _value_T_3 = value_1 + 8'h1; // @[Counter.scala 76:24]
  assign ram_io_deq_bits_MPORT_addr = value_1;
  assign ram_io_deq_bits_MPORT_data = ram[ram_io_deq_bits_MPORT_addr]; // @[Decoupled.scala 218:16]
  assign ram_io_deq_bits_MPORT_data = ram_io_deq_bits_MPORT_addr >= 8'hc8 ? _RAND_1[8:0] :
    ram[ram_io_deq_bits_MPORT_addr]; // @[Decoupled.scala 218:16]
  assign ram_MPORT_data = io_enq_bits;
  assign ram_MPORT_addr = value;
  assign ram_MPORT_mask = 1'h1;
  assign ram_MPORT_en = io_enq_ready & io_enq_valid;
  assign io_enq_ready = ~full; // @[Decoupled.scala 241:19]
  assign io_deq_valid = ~empty; // @[Decoupled.scala 240:19]
  assign io_deq_bits = ram_io_deq_bits_MPORT_data; // @[Decoupled.scala 242:15]
  always @(posedge clock) begin
    if(ram_MPORT_en & ram_MPORT_mask) begin
      ram[ram_MPORT_addr] <= ram_MPORT_data; // @[Decoupled.scala 218:16]
    end
    if (reset) begin // @[Counter.scala 60:40]
      value <= 8'h0; // @[Counter.scala 60:40]
    end else if (do_enq) begin // @[Decoupled.scala 229:17]
      if (wrap) begin // @[Counter.scala 86:20]
        value <= 8'h0; // @[Counter.scala 86:28]
      end else begin
        value <= _value_T_1; // @[Counter.scala 76:15]
      end
    end
    if (reset) begin // @[Counter.scala 60:40]
      value_1 <= 8'h0; // @[Counter.scala 60:40]
33:17]d else if (do_deq) begin // @[Decoupled.scala 2
      if (wrap_1) begin // @[Counter.scala 86:20]
        value_1 <= 8'h0; // @[Counter.scala 86:28]
      end else begin
        value_1 <= _value_T_3; // @[Counter.scala 76:15]
      end
    end
    if (reset) begin // @[Decoupled.scala 221:27]
      maybe_full <= 1'h0; // @[Decoupled.scala 221:27]
    end else if (do_enq != do_deq) begin // @[Decoupled.scala 236:28]
      maybe_full <= do_enq; // @[Decoupled.scala 237:16]
    end
  end
```

è¿™ä¸ª Verilog æ˜¯ Chisel ç”Ÿæˆçš„ **æ·±åº¦ä¸º 200 çš„ FIFO é˜Ÿåˆ—ï¼ˆQueueï¼‰å®ç°**ï¼Œå®ƒçš„ç»“æ„å’Œè¡Œä¸ºå¯ä»¥æŒ‰å‡ ä¸ªæ ¸å¿ƒéƒ¨åˆ†ç†è§£ï¼š

1.  **å­˜å‚¨é˜µåˆ—ï¼ˆRAMï¼‰**

```
reg [8:0] ram [0:199];
```

-   é˜Ÿåˆ—çš„æ•°æ®å­˜å‚¨åœ¨ä¸€ä¸ª 200 æ·±åº¦ã€æ¯ä¸ªå…ƒç´  9 ä½çš„å¯„å­˜å™¨æ•°ç»„ä¸­ã€‚

2.   **è¯»å†™æŒ‡é’ˆ**

```
reg [7:0] value;   // å†™æŒ‡é’ˆ
reg [7:0] value_1; // è¯»æŒ‡é’ˆ
```

-   `value` æŒ‡å‘ä¸‹ä¸€ä¸ªå…¥é˜Ÿä½ç½®ï¼Œ`value_1` æŒ‡å‘ä¸‹ä¸€ä¸ªå‡ºé˜Ÿä½ç½®ã€‚
-   æŒ‡é’ˆä¼šåœ¨å…¥é˜Ÿ/å‡ºé˜Ÿæ—¶é€’å¢ï¼Œå¹¶åœ¨åˆ°è¾¾æ•°ç»„æœ«å°¾æ—¶ wrap å› 0ï¼Œå®ç°å¾ªç¯é˜Ÿåˆ—ã€‚

3.   **é˜Ÿåˆ—çŠ¶æ€åˆ¤æ–­**

```
reg maybe_full;
wire ptr_match = value == value_1;
wire empty = ptr_match & ~maybe_full;
wire full = ptr_match & maybe_full;
```

-   å½“è¯»å†™æŒ‡é’ˆç›¸ç­‰æ—¶ï¼Œé€šè¿‡ `maybe_full` åŒºåˆ†é˜Ÿåˆ—æ˜¯ç©ºè¿˜æ˜¯æ»¡ã€‚
-   `empty` é«˜æ—¶è¡¨ç¤ºé˜Ÿåˆ—ä¸ºç©ºï¼Œ`full` é«˜æ—¶è¡¨ç¤ºé˜Ÿåˆ—å·²æ»¡ã€‚

4.   **å…¥é˜Ÿ/å‡ºé˜Ÿæ¡æ‰‹**

```
wire do_enq = io_enq_ready & io_enq_valid;
wire do_deq = io_deq_ready & io_deq_valid;
```

-   åªæœ‰å½“ **valid ä¸ ready åŒæ—¶ä¸ºé«˜** æ—¶ï¼Œæ•°æ®æ‰å®é™…å†™å…¥æˆ–è¯»å‡ºã€‚
-   è¿™å°±æ˜¯ Chisel `Decoupled` çš„æ¡æ‰‹æœºåˆ¶ã€‚

5.   **RAM å†™å…¥é€»è¾‘**

```
if(ram_MPORT_en & ram_MPORT_mask) begin
  ram[ram_MPORT_addr] <= ram_MPORT_data;
end
```

-   `ram_MPORT_en` ç”± `do_enq` æ§åˆ¶ï¼Œåªæœ‰å…¥é˜Ÿæ—¶æ‰å†™ RAMã€‚

6.   **æŒ‡é’ˆæ›´æ–°**

```
if (do_enq) value <= wrap ? 0 : value + 1;
if (do_deq) value_1 <= wrap_1 ? 0 : value_1 + 1;
maybe_full <= do_enq != do_deq ? do_enq : maybe_full;
```

-   å†™æŒ‡é’ˆåœ¨å…¥é˜Ÿæ—¶åŠ  1ï¼Œå‡ºé˜ŸæŒ‡é’ˆåœ¨å‡ºé˜Ÿæ—¶åŠ  1ã€‚
-   `maybe_full` ç”¨äºåˆ¤æ–­é˜Ÿåˆ—æ»¡ç©ºçŠ¶æ€å˜åŒ–ã€‚

7.   **è¾“å‡ºä¿¡å·**

```
assign io_enq_ready = ~full;
assign io_deq_valid = ~empty;
assign io_deq_bits = ram[read_ptr];
```

-   é˜Ÿåˆ—æœªæ»¡æ—¶ `io_enq_ready=1`ï¼Œå¯ä»¥å…¥é˜Ÿã€‚
-   é˜Ÿåˆ—éç©ºæ—¶ `io_deq_valid=1`ï¼Œå¯ä»¥å‡ºé˜Ÿã€‚
-   å‡ºé˜Ÿæ•°æ®ä» `ram` çš„è¯»æŒ‡é’ˆä½ç½®è¾“å‡ºã€‚



### æµ‹è¯•

==**æ„å»ºæµ‹è¯•ï¼š**==

pokeæ¥è®¾å®šè¾“å…¥

expectæ¥å‡å®šè¾“å‡ºï¼ˆæˆ–è€…ç”¨peekæ¥è§‚å¯Ÿè¾“å‡ºï¼‰

```scala
test(new Passthrough()) { c =>
    c.io.in.poke(0.U)     // Set our input to value 0
    c.io.out.expect(0.U)  // Assert that the output correctly has 0
    c.io.in.poke(1.U)     // Set our input to value 1
    c.io.out.expect(1.U)  // Assert that the output correctly has 1
    c.io.in.poke(2.U)     // Set our input to value 2
    c.io.out.expect(2.U)  // Assert that the output correctly has 2
}
println("SUCCESS!!") // Scala Code: if we get here, our tests passed!

test(new PassthroughGenerator(10)) { c =>	// generatorä¸€æ ·ç›´æ¥ä¼ å‚å°±è¡Œ
    c.io.in.poke(0.U)
    c.io.out.expect(0.U)
    c.io.in.poke(1023.U)
    c.io.out.expect(1023.U)
}
println("SUCCESS!!") // Scala Code: if we get here, our tests passed!
```

![image-20250924102155554](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250924102155554.png)

==**List ç®€åŒ–æµ‹è¯•é€»è¾‘**==

```scala
// Here's the tester
test(new Sort4) { c =>
  // verify the all possible ordering of 4 numbers are sorted
  List(1, 2, 3, 4).permutations.foreach { case i0 :: i1 :: i2 :: i3 :: Nil =>
    println(s"Sorting $i0 $i1 $i2 $i3")
    c.io.in0.poke(i0.U)
    c.io.in1.poke(i1.U)
    c.io.in2.poke(i2.U)
    c.io.in3.poke(i3.U)
    c.io.out0.expect(1.U)
    c.io.out1.expect(2.U)
    c.io.out2.expect(3.U)
    c.io.out3.expect(4.U)
  }
}
println("SUCCESS!!") // Scala Code: if we get here, our tests passed!
```

```scala
List(1, 2, 3, 4).permutations.foreach { ... }
```

-   æšä¸¾ `[1,2,3,4]` çš„æ‰€æœ‰ **æ’åˆ—**ï¼ˆå…±æœ‰ 24 ç§ï¼‰ã€‚
-   å¯¹æ¯ç§æ’åˆ—ä¾æ¬¡æµ‹è¯•ã€‚ï¼ˆæ¯æ¬¡æœŸå¾…çš„ç»“æœéƒ½æ˜¯ä¸€æ ·çš„ï¼Œ1->2->3->4)



==**æ‰“å°æµ‹è¯•**==

åœ¨ **æ–°ç‰ˆ chiseltest** é‡Œï¼Œ`expect`ã€`poke`ã€`peek` åªæ˜¯æ£€æŸ¥/æ“ä½œæ¥å£ï¼Œä¸ä¼šç´¯è®¡åˆ°æµ‹è¯•è®¡æ•°é‡Œã€‚æµ‹è¯•é€šè¿‡ä¸å¦åªçœ‹æœ‰æ²¡æœ‰æŠ›å¼‚å¸¸ï¼Œæ‰€ä»¥ç»“æœæ°¸è¿œæ˜¯ 0 tests passed.



![image-20250924103256540](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250924103256540.png)

```scala
class PrintingModule extends Module {
    val io = IO(new Bundle {
        val in = Input(UInt(4.W))
        val out = Output(UInt(4.W))
    })
    io.out := io.in

    printf("Print during simulation: Input is %d\n", io.in)
    // chisel printf has its own string interpolator too
    printf(p"Print during simulation: IO is $io\n")

    println(s"Print during generation: Input is ${io.in}")
}

test(new PrintingModule ) { c =>
    c.io.in.poke(3.U)
    c.clock.step(5) // circuit will print(åˆ›å»º5æ¬¡)
    
    println(s"Print during testing: Input is ${c.io.in.peek()}")	//ç”¨peekæ¥æ•è·è¾“å…¥å€¼
}
```

![image-20250924103121107](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20250924103121107.png)

åœ¨æµ‹è¯•é‡Œåª `poke(3.U)` è¿‡ä¸€æ¬¡ï¼Œç„¶å `step(5)` æ¨è¿›äº† 5 ä¸ªå‘¨æœŸã€‚æœŸé—´ `io.in` ä¸€ç›´æ˜¯ 3ï¼Œæ‰€ä»¥ä»¿çœŸæ‰“å°äº† 5 æ¬¡ã€‚

ä½† **æµ‹è¯•ç»“æŸæ—¶**ï¼Œchisel-testers æ¡†æ¶ä¼šåœ¨æœ€åå†è·‘ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸæ¥æ”¶å°¾ï¼ˆflush ä»¿çœŸï¼‰ï¼Œè¿™æ—¶å€™ `poke(3.U)` çš„ä½œç”¨åŸŸç»“æŸäº†ï¼Œè¾“å…¥ç«¯å£ `io.in` æ²¡æœ‰å†è¢«é©±åŠ¨ï¼Œæ‰€ä»¥å®ƒå›åˆ°äº†é»˜è®¤å€¼ 0ã€‚äºæ˜¯çœ‹åˆ°æœ€åå¤šäº†ä¸€æ¬¡



==é’ˆå¯¹Decoupledä¿¡å·çš„æµ‹è¯•==

```scala
test(new QueueModule(UInt(9.W), entries = 200)) { c =>	//c æ˜¯å¯¹æ¨¡å—çš„æµ‹è¯•å¥æŸ„
    c.in.initSource()
    c.in.setSourceClock(c.clock)
    c.out.initSink()
    c.out.setSinkClock(c.clock)
    
    val testVector = Seq.tabulate(200){ i => i.U }	//testVector = [0.U, 1.U, 2.U, 3.U, ..., 199.U]

    testVector.zip(testVector).foreach { case (in, out) =>	
      c.in.enqueueNow(in)
      c.out.expectDequeueNow(out)
    }
}
```

å› ä¸ºè¿™é‡Œç”¨çš„æ˜¯ `Seq.tabulate(200){ i => i.U }`ã€‚

-   `Seq.tabulate(n)(f)` ä¼šç”Ÿæˆé•¿åº¦ä¸º `n` çš„åºåˆ—ï¼Œç´¢å¼• `i` **ä» 0 å¼€å§‹**åˆ° `n-1`ã€‚
-   æ‰€ä»¥ `n = 200` æ—¶ï¼Œ`i` å°±ä» `0` åˆ° `199`ã€‚
-   æ¯ä¸ª `i` å†é€šè¿‡ `i.U` è½¬æˆ Chisel çš„ `UInt`ï¼Œå¾—åˆ° `[0.U, 1.U, â€¦, 199.U]`ã€‚

ç®€è€Œè¨€ä¹‹ï¼š**Seq.tabulate çš„ç´¢å¼•é»˜è®¤ä» 0 å¼€å§‹ï¼Œæ‰€ä»¥è‡ªç„¶ç”Ÿæˆ 0 åˆ° 199 çš„åºåˆ—**ã€‚

```scala
testVector.zip(testVector).foreach { case (in, out) =>	
      c.in.enqueueNow(in)
      c.out.expectDequeueNow(out)
}
```

1.  **`testVector.zip(testVector)`**

-   `zip` ä¼šæŠŠä¸¤ä¸ªåºåˆ—ä¸€ä¸€é…å¯¹ï¼Œç”Ÿæˆä¸€ä¸ª **(è¾“å…¥å€¼, æœŸæœ›è¾“å‡ºå€¼)** çš„åºåˆ—ã€‚

-   ```scala
    val a = Seq(1, 2, 3)
    val b = Seq("x", "y", "z")
    val c = a.zip(b)
    // c: Seq[(Int, String)] = Seq((1,"x"), (2,"y"), (3,"z"))
    ```

-   è¿™é‡Œä¸¤ä¸ªåºåˆ—ç›¸åŒï¼Œæ‰€ä»¥é…å¯¹ç»“æœæ˜¯ `(0,0), (1,1), â€¦, (199,199)`ã€‚

-   ç”¨æ¥ä¿è¯ FIFO å…¥é˜Ÿçš„æ•°æ®å’Œå‡ºé˜Ÿçš„æ•°æ®é¡ºåºä¸€è‡´ã€‚

2.   **`.foreach { case (in, out) => ... }`**

-   éå†æ¯ä¸€ä¸ª `(in, out)` å…ƒç»„ã€‚

-   `case (in, out)` æ˜¯ **Scala çš„æ¨¡å¼åŒ¹é…è§£æ„è¯­æ³•**ï¼Œåœ¨ `foreach` æˆ– `map` é‡Œç”¨æ¥æŠŠäºŒå…ƒç»„ `(a, b)` æ‹†å¼€æˆä¸¤ä¸ªå˜é‡ã€‚

-   `zip` ç”Ÿæˆçš„æ˜¯ `(in, out)` äºŒå…ƒç»„åºåˆ—ã€‚

    `case (in, out)` æŠŠæ¯ä¸ªäºŒå…ƒç»„æ‹†æˆä¸¤ä¸ªå˜é‡ `in` å’Œ `out`ï¼Œæ–¹ä¾¿åœ¨å¾ªç¯ä½“ä¸­ç›´æ¥ä½¿ç”¨ã€‚

    å¦‚æœä¸å†™ `case`ï¼Œä½ åªèƒ½ç”¨ä¸€ä¸ªå˜é‡æ¥æ”¶å…ƒç»„ï¼Œç„¶åå†é€šè¿‡ `_1` å’Œ `_2` è®¿é—®å…ƒç´ ï¼Œä¾‹å¦‚ï¼š

-   ```scala
    .foreach { tuple => 
      c.in.enqueueNow(tuple._1)
      c.out.expectDequeueNow(tuple._2)
    }
    ```

3.   **`c.in.enqueueNow(in)`**

-   å°† `in` ç«‹å³é€å…¥é˜Ÿåˆ—çš„è¾“å…¥ç«¯ï¼ˆ`Decoupled` æ¥å£ï¼‰ï¼Œä»¿çœŸä¸­ valid-ready æ¡æ‰‹ç«‹å³å®Œæˆã€‚

4.   **`c.out.expectDequeueNow(out)`**

-   æ£€æŸ¥é˜Ÿåˆ—è¾“å‡ºç«¯ï¼ˆ`Decoupled`ï¼‰å½“å‰å€¼æ˜¯å¦ç­‰äº `out`ã€‚

`enqueueNow` ç”¨äº **ç›´æ¥é€å…¥æ•°æ®**ï¼Œ`expectDequeueNow` ç”¨äº **ç›´æ¥éªŒè¯è¾“å‡ºæ•°æ®**ã€‚

è¿™ä¸¤ä¸ªæ–¹æ³•é€‚åˆ **åŒæ­¥ã€ç«‹å³éªŒè¯ FIFO é¡ºåº**ï¼Œæ— éœ€æ‰‹åŠ¨ç®¡ç† clock/valid/ready ä¿¡å·ã€‚

**æ€»ç»“**ï¼š

-   è¿™è¡Œä»£ç å°±æ˜¯ **é¡ºåºæŠŠ testVector çš„æ•°æ®å…¥é˜Ÿ FIFOï¼Œç„¶åç«‹åˆ»æ£€æŸ¥å‡ºé˜Ÿæ•°æ®æ˜¯å¦æŒ‰é¡ºåºè¾“å‡º**ã€‚
-   å®ç°äº†å¯¹ FIFO **å…ˆè¿›å…ˆå‡ºè¡Œä¸ºçš„è‡ªåŠ¨éªŒè¯**ã€‚



==**å¹¶å‘æ‰§è¡Œ fork & join**==

```scala
test(new QueueModule(UInt(9.W), entries = 200)) { c =>
    // Example testsequence showing the use and behavior of Queue
    c.in.initSource()
    c.in.setSourceClock(c.clock)
    c.out.initSink()
    c.out.setSinkClock(c.clock)
    
    val testVector = Seq.tabulate(300){ i => i.U }	//testVector = 0~299ï¼šå‡†å¤‡ 300 ä¸ªå¾…æµ‹è¯•çš„æ•°æ®

    fork {
        c.in.enqueueSeq(testVector)
    }.fork {
        c.out.expectDequeueSeq(testVector)
    }.join()
}
```

`fork { ... }`ï¼šåœ¨æµ‹è¯•ç¯å¢ƒé‡Œå¯åŠ¨ä¸€ä¸ªå¹¶å‘çš„æµ‹è¯•çº¿ç¨‹ï¼š

`fork` åä¸¤ä¸ªçº¿ç¨‹æ˜¯**å¹¶å‘è°ƒåº¦**çš„ã€‚ä¿è¯æ­£ç¡®æ€§çš„åŸå› åœ¨äº**Chisel çš„ Decoupled æ¥å£æ¡æ‰‹åè®®**ï¼ˆ`valid` / `ready`ï¼‰ï¼š

-   `enqueueSeq` ä¼šåœ¨ `in.ready` ä¸ºé«˜æ—¶æ‰å‘é€ä¸‹ä¸€ä¸ªæ•°æ®ã€‚
-   `expectDequeueSeq` ä¼šåœ¨ `out.valid` ä¸ºé«˜æ—¶æ‰æ¥æ”¶å¹¶æ£€æŸ¥æ•°æ®ã€‚
-   åªæœ‰å½“ç¡¬ä»¶ queue å†…éƒ¨çœŸçš„å®Œæˆä¸€æ¬¡ä¼ è¾“æ—¶ï¼ŒåŒæ–¹æ‰å„å‰è¿›ä¸€æ­¥ã€‚

æ‰€ä»¥å³ä½¿ä¸¤ä¸ªçº¿ç¨‹äº¤é”™æ‰§è¡Œï¼Œä¹Ÿä¸ä¼šâ€œè¯»æ¯”å†™æ—©â€æˆ–â€œå†™æ¯”è¯»å¤šâ€ï¼Œå› ä¸º ready/valid æ¡æ‰‹å¤©ç„¶åŒæ­¥äº†å…ˆåé¡ºåºã€‚

é“¾å¼ `fork{...}.fork{...}.join()`ï¼šç¬¬ä¸€ä¸ª `fork` è¿”å›ä¸€ä¸ªå¥æŸ„ï¼Œåœ¨è¯¥å¥æŸ„ä¸Šå† `fork` ä¼šå†å¯åŠ¨å¦ä¸€ä¸ªå¹¶å‘çº¿ç¨‹ï¼›æœ€åçš„ `.join()` ä¼šç­‰å¾…â€œè¿™æ¡é“¾ä¸Šå¯åŠ¨çš„æ‰€æœ‰çº¿ç¨‹â€ç»“æŸæ‰ç»§ç»­ã€‚ä¹Ÿå¯ä»¥å•ç‹¬å†™ï¼š

```scala
val t1 = fork { ... }
val t2 = fork { ... }
t1.join()
t2.join()
```

è¿™æ˜¯**åˆ†åˆ« fork**ï¼š

-   t1ã€t2 ç‹¬ç«‹ï¼›
-   ä½ å¯ä»¥é€‰æ‹©å…ˆç­‰ t1 å†ç­‰ t2ï¼Œä¹Ÿå¯ä»¥åªç­‰å…¶ä¸­ä¸€ä¸ªï¼Œæ§åˆ¶æ›´çµæ´»ï¼›

==ä¾‹å­2ï¼šè®¡ç®—æœ€å¤§å…¬çº¦æ•°==

```scala
class DecoupledGcd(width: Int) extends MultiIOModule {

  val input = IO(Flipped(Decoupled(new GcdInputBundle(width))))
  val output = IO(Decoupled(new GcdOutputBundle(width)))

  val xInitial    = Reg(UInt())
  val yInitial    = Reg(UInt())
  val x           = Reg(UInt())
  val y           = Reg(UInt())
  val busy        = RegInit(false.B)
  val resultValid = RegInit(false.B)

  input.ready := ! busy
  output.valid := resultValid
  output.bits := DontCare

  when(busy)  {
    when(x > y) {
      x := x - y
    }.otherwise {
      y := y - x
    }
    when(y === 0.U) {
      output.bits.value1 := xInitial
      output.bits.value2 := yInitial
      output.bits.gcd := x
      output.valid := true.B
      busy := ! output.ready
    }
  }.otherwise {
    when(input.valid) {	//è¡¨ç¤ºä¸Šæ¸¸æä¾›äº†æœ‰æ•ˆæ•°æ®ä¸”æ¨¡å—ç©ºé—²ï¼ˆbusy = falseï¼‰
      val bundle = input.deq()	//ä» Decoupled è¾“å…¥ç«¯å£å–å‡ºæ•°æ®ï¼ˆå®Œæˆæ¡æ‰‹ï¼‰
      x := bundle.value1
      y := bundle.value2
      xInitial := bundle.value1
      yInitial := bundle.value2
      busy := true.B
      resultValid := false.B
    }
  }
}
```

è¿è¡Œè¿‡ç¨‹å¦‚ä¸‹ï¼š

1.  ç©ºé—²çŠ¶æ€ï¼Œ`busy = false`ï¼Œ`input.ready = 1`ã€‚
2.  ä¸Šæ¸¸çœ‹åˆ° `ready=1`ï¼ŒåŒæ—¶æ‹‰ `input.valid=1`ï¼Œå‘é€ `{48, 18}`ã€‚
3.  æ¡æ‰‹å®Œæˆ â†’ `deq()` â†’ x=48ï¼Œy=18ï¼Œå¼€å§‹è®¡ç®—ï¼Œ`busy=1`ã€‚

`deq()` æ˜¯**æµ‹è¯•åº“é‡Œæ–¹ä¾¿ä½¿ç”¨çš„ä¸€ä¸ªæ–¹æ³•**ï¼Œç”¨æ¥ä» Decoupled/Flipped è¾“å…¥ç«¯å£å–å‡ºæ•°æ®ï¼ŒåŒæ—¶å®Œæˆæ¡æ‰‹ï¼ˆ`valid && ready`ï¼‰ï¼š

-   å®ƒç›¸å½“äº**â€œç­‰å¾… input.valid ä¸ºé«˜ï¼ˆè¾“å…¥ç«¯æ•°æ®æœ‰æ•ˆï¼‰ï¼Œç„¶åæ‹‰é«˜ readyï¼ˆæ¥æ”¶ç«¯å¯ä»¥æ¥å—ï¼‰ï¼ŒæŠŠæ•°æ®å–å‡ºæ¥â€**ã€‚
-   è¿”å›å€¼æ˜¯ç«¯å£çš„ `bits`ï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œçš„ `bundle`ã€‚

è®¡ç®—è¿‡ç¨‹ï¼š

-   x=48 > y=18 â†’ x=48-18=30
-   x=30 > y=18 â†’ x=30-18=12
-   y=18 > x=12 â†’ y=18-12=6
-   x=12 > y=6 â†’ x=12-6=6
-   y=6 > x=6 â†’ y=6-6=0

æ­¤æ—¶ `y==0`ï¼š

4.   å°† `x=6` ä½œä¸ºç»“æœè¾“å‡ºï¼Œ`output.valid=1`ï¼Œç­‰å¾… `output.ready=1`ã€‚
5.   ä¸‹æ¸¸æ‹‰é«˜ `output.ready` â†’ æ¡æ‰‹æˆåŠŸ â†’ busy ç½® 0 â†’ æ¨¡å—å›åˆ°ç©ºé—²çŠ¶æ€ã€‚

æµ‹è¯•ç¼–å†™ï¼š

```scala
test(new DecoupledGcd(16)) { dut =>
  dut.input.initSource().setSourceClock(dut.clock)
  dut.output.initSink().setSinkClock(dut.clock)

  val testValues = for { x <- 1 to 10; y <- 1 to 10} yield (x, y)	//ç”Ÿæˆæ•°æ®ç»„åˆ
  val inputSeq = testValues.map { case (x, y) =>
    (new GcdInputBundle(16)).Lit(_.value1 -> x.U, _.value2 -> y.U)	//å¿«æ·åˆå§‹åŒ–
  }
  val resultSeq = testValues.map { case (x, y) =>	//æœŸæœ›è¾“å‡ºåºåˆ—
    new GcdOutputBundle(16).Lit(_.value1 -> x.U, _.value2 -> y.U, _.gcd -> BigInt(x).gcd(BigInt(y)).U)	//BigInt(x).gcd(BigInt(y))ï¼šç”¨æ¥è®¡ç®—ä¸¤ä¸ªå¤§æ•´æ•°çš„æœ€å¤§å…¬çº¦æ•°
  }

  fork {
    dut.input.enqueueSeq(inputSeq)
  }.fork {
    for (expected <- resultSeq) {	//éå†ä¹‹å‰ç”Ÿæˆçš„æ‰€æœ‰æœŸæœ›è¾“å‡º
      dut.output.expectDequeue(expected)
      dut.clock.step(5) // åœ¨è¯»å–ä¸‹ä¸€ä¸ªè¾“å‡ºå‰ç­‰å¾… 5 ä¸ªæ—¶é’Ÿå‘¨æœŸï¼Œæ¨¡æ‹Ÿä¸‹æ¸¸æ¥æ”¶æ…¢çš„æƒ…å†µï¼Œå³backpressure
    }
  }.join()
}
```

éªŒè¯è¾“å…¥â€“è®¡ç®—â€“è¾“å‡ºé€»è¾‘ï¼Œå¹¶æ¼”ç¤º **backpressure**ï¼ˆè¾“å‡ºç«¯å»¶è¿Ÿæ¥æ”¶ï¼‰çš„å¤„ç†ï¼š

-   `dut.input.initSource()` / `setSourceClock(...)`ï¼šåˆå§‹åŒ–è¾“å…¥é©±åŠ¨å™¨ï¼Œç»‘å®šæ—¶é’Ÿã€‚
-   `dut.output.initSink()` / `setSinkClock(...)`ï¼šåˆå§‹åŒ–è¾“å‡ºæ¥æ”¶å™¨ï¼Œç»‘å®šæ—¶é’Ÿã€‚

æµ‹è¯•æ•°æ®ï¼š

-   `testValues` ç”Ÿæˆ `(1,1)` åˆ° `(10,10)` çš„æ‰€æœ‰ç»„åˆã€‚
-   `inputSeq`ï¼šæŠŠæ¯å¯¹ `(x,y)` å°è£…æˆ `GcdInputBundle`ï¼Œç”¨äºå‘é€ã€‚
-   `resultSeq`ï¼šè®¡ç®—å¯¹åº”çš„ GCDï¼Œå°è£…æˆ `GcdOutputBundle`ï¼Œç”¨äºéªŒè¯è¾“å‡ºã€‚

fork å¹¶å‘æµ‹è¯•ï¼š

1.  è¾“å…¥çº¿ç¨‹ï¼š`enqueueSeq(inputSeq)` è¿ç»­å‘é€æ‰€æœ‰è¾“å…¥åˆ°æ¨¡å—ã€‚
2.  è¾“å‡ºçº¿ç¨‹ï¼š
    -   éå† `resultSeq`ï¼Œè°ƒç”¨ `expectDequeue(expected)` éªŒè¯è¾“å‡ºå€¼æ­£ç¡®ã€‚
    -   `clock.step(5)` æ¨¡æ‹Ÿè¾“å‡ºç«¯å»¶è¿Ÿï¼Œäº§ç”Ÿ backpressureï¼Œè®©é˜Ÿåˆ—å’Œæ¨¡å—å¤„ç†æ¡æ‰‹æš‚åœã€‚

`.join()`ï¼šç­‰å¾…ä¸¤ä¸ªçº¿ç¨‹éƒ½å®Œæˆï¼Œä¿è¯æµ‹è¯•å®Œæ•´ã€‚

```scala
new GcdInputBundle(16)).Lit(_.value1 -> x.U, _.value2 -> y.U
```

è¿™è¡Œä»£ç æ˜¯åœ¨ **Chisel 3 çš„ Bundle literal åˆå§‹åŒ–**è¯­æ³•ï¼Œç”¨æ¥å¿«é€Ÿç”Ÿæˆå¸¦å›ºå®šå€¼çš„ `GcdInputBundle` å®ä¾‹ï¼š

-   `new GcdInputBundle(16)`ï¼šåˆ›å»ºä¸€ä¸ªå®½åº¦ 16 çš„è¾“å…¥ Bundleï¼ˆå‡è®¾æœ‰ `value1` å’Œ `value2` å­—æ®µï¼‰ã€‚
-   `.Lit(...)`ï¼šç”¨ literal æ–¹å¼ç»™ Bundle å†…éƒ¨çš„å­—æ®µèµ‹åˆå€¼ï¼Œç”Ÿæˆå¯ç›´æ¥ä½œä¸ºæµ‹è¯•è¾“å…¥çš„å¸¸é‡ã€‚
-   `_.value1 -> x.U, _.value2 -> y.U`ï¼šæŠŠ Bundle çš„ `value1` å­—æ®µèµ‹å€¼ä¸º `x.U`ï¼Œ`value2` èµ‹å€¼ä¸º `y.U`ã€‚

ä½œç”¨ï¼šç”Ÿæˆä¸€ä¸ª **å¸¦å…·ä½“æ•°æ®çš„è¾“å…¥ Bundle**ï¼Œå¯ç›´æ¥é€å…¥ `enqueueSeq` æµ‹è¯•æ¨¡å—ã€‚

ç­‰ä»·æ‰‹å†™æ–¹å¼ï¼š

```
val bundle = Wire(new GcdInputBundle(16))
bundle.value1 := x.U
bundle.value2 := y.U
```

ä½† `.Lit` æ›´ç®€æ´ï¼Œå°¤å…¶åœ¨ç”Ÿæˆåºåˆ—æ—¶æ–¹ä¾¿ã€‚

`.Lit` åœ¨ Chisel é‡Œå¯ä»¥ç”¨åœ¨**ä»»ä½• Bundle æˆ– Vec ä¸Š**ï¼Œç”¨äºå¿«é€Ÿç”Ÿæˆå¸¦å›ºå®šå€¼çš„ç¡¬ä»¶å¸¸é‡ï¼š

-   **Bundle**ï¼šç»™å¤šä¸ªå­—æ®µåŒæ—¶èµ‹å€¼ï¼Œå¦‚ `MyBundle(width).Lit(_.a -> 3.U, _.b -> 7.U)`ã€‚
-   **Vec**ï¼šç»™å‘é‡æ¯ä¸ªå…ƒç´ èµ‹å€¼ï¼Œå¦‚ `Vec(3, UInt(8.W)).Lit(1.U, 2.U, 3.U)`ã€‚



### å‚æ•°åŒ–

==åˆ›å»ºå«å‚moduleï¼ˆæˆ–è€…å«åš **generator**ï¼Œå› ä¸ºå¯ä»¥ä»£è¡¨ä¸€ç±»çš„moduleï¼‰ï¼š==

```scala
class ParameterizedWidthAdder(in0Width: Int, in1Width: Int, sumWidth: Int) extends Module {
  require(in0Width >= 0)	//pre-elaboration assertionsï¼ˆæ–­è¨€ï¼‰
  require(in1Width >= 0)
  require(sumWidth >= 0)
  val io = IO(new Bundle {
    val in0 = Input(UInt(in0Width.W))
    val in1 = Input(UInt(in1Width.W))
    val sum = Output(UInt(sumWidth.W))
  })
  // a +& b includes the carry, a + b does not
  io.sum := io.in0 +& io.in1
}

println(getVerilog(new ParameterizedWidthAdder(1, 4, 6)))
```

==ä¾‹å­1ï¼šé€šè¿‡å‚æ•°åŒ–æ§åˆ¶èµ‹å€¼æ–¹å‘==

```scala
class Sort2(ascending: Boolean) extends Module {
  val io = IO(new Bundle {
    val in0 = Input(UInt(16.W))
    val in1 = Input(UInt(16.W))
  })
    
  def comp(l: UInt, r: UInt): Bool = {	//è¿”å›boolå€¼	
      if (ascending) {
        l < r	//å¦‚æœl<rè¿”å›çœŸå¦åˆ™è¿”å›å‡
      } else {
        l > r
    }
  }

  val row10 = Wire(UInt(16.W))
  val row11 = Wire(UInt(16.W))

  when(comp(io.in0, io.in1)) {
    row10 := io.in0            // l<r ä¿æŒä½ç½®ä¸å˜
    row11 := io.in1
  }.otherwise {
    row10 := io.in1            // l>r äº¤æ¢ä¸¤è€…ä½ç½®
    row11 := io.in0
  }
```

![image-20251015114800607](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20251015114800607.png)

==Generators and Collections:==

å¯ä»¥ä¼ é€’ä¸å›ºå®šçš„å‚æ•°ä¸ªæ•°ï¼š

eg. FIRæ»¤æ³¢å™¨ï¼š
$$
y[n] = \sum_{k=0}^{N-1} h[k] \cdot x[n - k]
$$
å…¶ä¸­ï¼š

-   ( y[n] )ï¼šå½“å‰è¾“å‡ºï¼›
-   ( x[n-k] )ï¼šå½“å‰åŠè¿‡å»çš„è¾“å…¥æ ·æœ¬ï¼›
-   ( h[k] )ï¼šæ»¤æ³¢å™¨çš„ç³»æ•°ï¼ˆtapsï¼‰ï¼›
-   ( N )ï¼šæ»¤æ³¢å™¨é˜¶æ•°ï¼ˆç³»æ•°ä¸ªæ•°ï¼‰ã€‚

ç®€å•æ¥è¯´ï¼Œå°±æ˜¯æŠŠå½“å‰è¾“å…¥å’Œä¹‹å‰çš„è¾“å…¥æŒ‰æƒé‡ ( h[k] ) åšåŠ æƒæ±‚å’Œã€‚

```scala
class ScalaFirFilter(taps: Seq[Int]) {	//taps: Seq[Int]ï¼šæ»¤æ³¢å™¨çš„ç³»æ•°æ•°ç»„ï¼Œé•¿åº¦ä¸å›ºå®š
  var pseudoRegisters = List.fill(taps.length)(0)	//åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸æ»¤æ³¢ç³»æ•°ç›¸åŒã€åˆå§‹å…¨ä¸º 0 çš„åˆ—è¡¨ï¼Œç”¨æ¥ä¿å­˜è¾“å…¥å†å²ï¼ˆç›¸å½“äºç§»ä½å¯„å­˜å™¨ï¼‰

  def poke(value: Int): Int = {
    pseudoRegisters = value :: pseudoRegisters.take(taps.length - 1)	//é¦–å…ˆç”¨takeå–å‡ºlisté‡Œé¢é™¤å»æœ€åä¸€ä¸ªå…ƒç´ åçš„åˆ—è¡¨ï¼Œç„¶åç”¨::æ“ä½œç¬¦å°†æ–°çš„æ•°æ®åˆå¹¶åˆ°listä¸­å»
    var accumulator = 0
    for(i <- taps.indices) {	//éå†åºåˆ— taps çš„æ‰€æœ‰ç´¢å¼•ï¼ˆå³ä» 0 åˆ° taps.length - 1ï¼‰
      accumulator += taps(i) * pseudoRegisters(i)
    }
    accumulator
  }
}
```

æµ‹è¯•ï¼š

```scala
val filter = new ScalaFirFilter(Seq(1, 1, 1, 1))	//ç³»æ•°éƒ½å®šä¸º1ï¼Œé•¿åº¦N=4

var out = 0

out = filter.poke(1)
println(s"out = $out")	
assert(out == 1)  // 1, 0, 0, 0

out = filter.poke(4)	
assert(out == 5)  // 4, 1, 0, 0		Liståˆ—è¡¨ä»å¤´åŠ å…¥
println(s"out = $out")

out = filter.poke(3)
assert(out == 8)  // 3, 4, 1, 0
println(s"out = $out")

out = filter.poke(2)
assert(out == 10)  // 2, 3, 4, 1
println(s"out = $out")

out = filter.poke(7)
assert(out == 16)  // 7, 2, 3, 4	å¤šå‡ºçš„å€¼ç›´æ¥æ¼æ‰äº†
println(s"out = $out")

out = filter.poke(0)
assert(out == 12)  // 0, 7, 2, 3
println(s"out = $out")
```

å¦ä¸€ç§å®ç°æ–¹å¼ï¼š

```scala
class MyManyElementFir(consts: Seq[Int], bitWidth: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(bitWidth.W))
    val out = Output(UInt(bitWidth.W))
  })

  val regs = mutable.ArrayBuffer[UInt]()	//ArrayBufferç±»ä¼¼listï¼Œé€šè¿‡+=æ¥æ·»åŠ å…ƒç´ 
  for(i <- 0 until consts.length) {
      if(i == 0) regs += io.in
      else       regs += RegNext(regs(i - 1), 0.U)	//RegNext(value, reset)ï¼šç”Ÿæˆä¸€ä¸ª Dè§¦å‘å™¨å¯„å­˜å™¨ï¼Œåœ¨ä¸‹ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸé‡‡æ · value çš„å€¼ï¼Œå¦‚æœå¤ä½å°±è®¾ä¸º resetï¼›
  }
  
  val muls = mutable.ArrayBuffer[UInt]()
  for(i <- 0 until consts.length) {
      muls += regs(i) * consts(i).U
  }

  val scan = mutable.ArrayBuffer[UInt]()
  for(i <- 0 until consts.length) {
      if(i == 0) scan += muls(i)
      else scan += muls(i) + scan(i - 1)	//scan(0) = muls(0) â†’ ç¬¬ä¸€ä¸ªä¹˜æ³•ç»“æœï¼›scan(1) = muls(1) + scan(0) â†’ å‰ä¸¤ä¸ªä¹˜æ³•ç»“æœçš„å’Œï¼›
  }

  io.out := scan.last	//ç”¨.lastè°ƒç”¨ArrayBufferçš„æœ€åä¸€ä¸ªå…ƒç´ 
}
```



### å‡½æ•°

==Get ä¸ Option==

è¿”å›å€¼ä¸ºOptionï¼ŒåŒ…æ‹¬ä¸¤ä¸ªå­é›† Some å’Œ None

```scala
val map = Map("a" -> 1)
val a = map.get("a")	
println(a)	//è¾“å‡ºSome(1)
val b = map.get("b")
println(b)	//è¾“å‡ºNone
val b = map("b")
println(b)	//ä¸ç”¨getçš„è¯ä¼šåœ¨è¿è¡Œæ—¶æŠ¥é”™
```

getOrElseå¯ä»¥ç»„åˆä½¿ç”¨

```scala
val some = Some(1)
val none = None
println(some.get)          // Returns 1
// println(none.get)       // Errors!
println(some.getOrElse(2)) // Returns 1
println(none.getOrElse(2)) // Returns 2
```

**Optionå¯ä»¥åˆå§‹åŒ–å‚æ•°çš„é»˜è®¤å€¼ä¸ºNone**

```scala
class DelayBy1(resetValue: Option[UInt] = None) extends Module {	//é»˜è®¤åˆå§‹åŒ–resetValueä¸ºNone
    val io = IO(new Bundle {
        val in  = Input( UInt(16.W))
        val out = Output(UInt(16.W))
    })
    val reg = if (resetValue.isDefined) { // resetValue = Some(number)
        RegInit(resetValue.get)
    } else { //resetValue = None
        Reg(UInt())
    }
    reg := io.in
    io.out := reg
}
```

```scala
println(getVerilog(new DelayBy1))	//æ²¡ç»™é»˜è®¤åˆå§‹å€¼
```

![image-20251028110120412](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20251028110120412.png)

```scala
println(getVerilog(new DelayBy1(Some(3.U))))	//ç»™äº†åˆå§‹å€¼ä¸º3
```

![image-20251028110228740](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20251028110228740.png)

==match==

ç”¨æ¥åšå¤æ‚ï¼ˆå¤šç§ç±»å‹ï¼‰çš„åŒ¹é…ï¼š

```scala
// y is an integer variable defined somewhere else in the code
val y = 7

val x = y match {
  case 0 => "zero" // One common syntax, preferred if fits in one line
  case 1 =>        // Another common syntax, preferred if does not fit in one line.
      "one"        // Note the code block continues until the next case
  case 2 => {      // Another syntax, but curly braces are not required
      "two"
  }
  case _ => "many" // _ ç”¨æ¥åŒ¹é…æ‰€æœ‰æ²¡æ‰¾åˆ°çš„å€¼
}
println("y is " + x)	//è¾“å‡ºy is many(å› ä¸º 7 ä¸åœ¨ä¸Šé¢ä¸‰ä¸ªçš„åŒ¹é…èŒƒå›´å†…)
```

å¤šä¸ªå˜é‡å¯ä»¥åœ¨ä¸€èµ·åšåŒ¹é…ï¼š

```scala
def animalType(biggerThanBreadBox: Boolean, meanAsCanBe: Boolean): String = {
  (biggerThanBreadBox, meanAsCanBe) match {
    case (true, true) => "wolverine"
    case (true, false) => "elephant"
    case (false, true) => "shrew"
    case (false, false) => "puppy"
  }
}
println(animalType(true, true))	//è¾“å‡º wolverine
```

æ ¹æ®æ•°æ®ç±»å‹æ¥åŒ¹é…ï¼š

```scala
val sequence = Seq("a", 1, 0.0)
sequence.foreach { x =>
  x match {
    case s: String => println(s"$x is a String")	
    case s: Int    => println(s"$x is an Int")	
    case s: Double => println(s"$x is a Double")	//è¿™é‡Œcaseåé¢è·Ÿçš„åå­—å¯ä»¥ç›¸åŒ/ä¸åŒï¼Œæ²¡å½±å“
    case _ => println(s"$x is an unknown type!")
  }
}
/* è¾“å‡º  
a is a String
1 is an Int
0.0 is a Double
*/
```

åŠ ä¸Š|æ¥å¢åŠ åˆ¤æ–­æ¡ä»¶ï¼š

```scala
val sequence = Seq("a", 1, 0.0)
sequence.foreach { x =>
  x match {
    case _: Int | _: Double => println(s"$x is a number!")	//è¿™é‡Œå¿…é¡»ç”¨ _ æ‰è¡Œ
    case _ => println(s"$x is an unknown type!")
  }
}
```

ä¸èƒ½ç”¨åµŒå¥—çš„æ•°æ®ç±»å‹æ¥åšåŒ¹é…ï¼šå› ä¸ºåœ¨è¿è¡Œçš„æ—¶å€™å†…éƒ¨çš„æ•°æ®ç±»å‹éƒ½è¢«erasedäº†ï¼Œå› æ­¤å®é™…ä¸Šåªä¼šåŒ¹é…åˆ°å¤–å±‚çš„Seq

```scala
val sequence = Seq(Seq("a"), Seq(1), Seq(0.0))
sequence.foreach { x =>
  x match {
    case s: Seq[String] => println(s"$x is a String")
    case s: Seq[Int]    => println(s"$x is an Int")
    case s: Seq[Double] => println(s"$x is a Double")
  }
}
/* è¾“å‡ºéƒ½åªåŒ¹é…ç¬¬ä¸€ä¸ª
List(a) is a String
List(1) is a String
List(0.0) is a String
*/
```

==Optional  IOsï¼š==

é€šè¿‡Optionæ¥åˆ›å»ºå¯å˜çš„ IO æ¥å£ï¼š

```scala
class HalfFullAdder(val hasCarry: Boolean) extends Module {
  val io = IO(new Bundle {
    val a = Input(UInt(1.W))
    val b = Input(UInt(1.W))
    val carryIn = if (hasCarry) Some(Input(UInt(1.W))) else None	//carryInç«¯å£çš„æœ‰æ— æ ¹æ®ä¼ å…¥å‚æ•°å˜åŒ–
    val s = Output(UInt(1.W))
    val carryOut = Output(UInt(1.W))
  })
  val sum = io.a +& io.b +& io.carryIn.getOrElse(0.U)
  io.s := sum(0)
  io.carryOut := sum(1)
}
```

æˆ–è€…å¯ä»¥é€šè¿‡å£°æ˜ 0ä½å®½çš„wireæ¥å®ç°Noneçš„æ›¿æ¢ï¼š

```scala
class HalfFullAdder(val hasCarry: Boolean) extends Module {
  val io = IO(new Bundle {
    val a = Input(UInt(1.W))
    val b = Input(UInt(1.W))
    val carryIn = Input(if (hasCarry) UInt(1.W) else UInt(0.W))	//0ä½å®½ç­‰æ•ˆäºæ²¡æœ‰è¿™ä¸ªç«¯å£
    val s = Output(UInt(1.W))
    val carryOut = Output(UInt(1.W))
  })
  val sum = io.a +& io.b +& io.carryIn
  io.s := sum(0)
  io.carryOut := sum(1)
}
```

==Implicits:==

ç”¨æ¥éšå¼ä¼ é€’å˜é‡é»˜è®¤å€¼ï¼š

```scala
object CatDog {
  implicit val numberOfCats: Int = 3
  //implicit val numberOfDogs: Int = 5		ä¸€ä¸ªé™å®šçš„scopeèŒƒå›´å†…åªèƒ½æœ‰ä¸€ä¸ªimplicitå€¼ï¼Œå¦åˆ™ä¼šæŠ¥é”™

  def tooManyCats(nDogs: Int)(implicit nCats: Int): Boolean = nCats > nDogs
    
  val imp = tooManyCats(2)    // Argument passed implicitly!
  val exp = tooManyCats(2)(1) // Argument passed explicitly!
}
CatDog.imp	//è¾“å‡ºtrue
CatDog.exp	//è¾“å‡ºfalse
```

å¯ä»¥ç”¨æ¥æ§åˆ¶è°ƒè¯•å˜é‡

```scala
sealed trait Verbosity
implicit case object Silent extends Verbosity	//Verbosityé»˜è®¤ä¸ºSilent
case object Verbose extends Verbosity			//Verbosityå¦ä¸€ä¸ªé€‰æ‹©ä¸ºVerbose

class ParameterizedWidthAdder(in0Width: Int, in1Width: Int, sumWidth: Int)(implicit verbosity: Verbosity)	//verbosityè®¾ç½®ä¸ºimplicitå˜é‡ï¼Œæ§åˆ¶æ˜¯å¦å¯åŠ¨è°ƒè¯•è¾“å‡º
extends Module {
  def log(msg: => String): Unit = verbosity match {
    case Silent =>	//å¦‚æœä¸ºSilentçš„è¯å°±ä¸è¾“å‡º
    case Verbose => println(msg)
  }
  require(in0Width >= 0)
  log(s"in0Width of $in0Width OK")
  require(in1Width >= 0)
  log(s"in1Width of $in1Width OK")
  require(sumWidth >= 0)
  log(s"sumWidth of $sumWidth OK")
  val io = IO(new Bundle {
    val in0 = Input(UInt(in0Width.W))
    val in1 = Input(UInt(in1Width.W))
    val sum = Output(UInt(sumWidth.W))
  })
  log("Made IO")
  io.sum := io.in0 + io.in1
  log("Assigned output")
}
```

```scala
println(getVerilog(new ParameterizedWidthAdder(1, 4, 5)(Verbose)))	//æ‰“å¼€è°ƒè¯•
```

![image-20251028140512799](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20251028140512799.png)

**éšå¼è½¬æ¢ Implicit Conversionï¼š**

```scala
class Animal(val name: String, val species: String)
class Human(val name: String)
implicit def human2animal(h: Human): Animal = new Animal(h.name, "Homo sapiens")
val me = new Human("Adam")
println(me.species)		//è¾“å‡ºHomo sapiens
```

å½“ä½ å†™ `me.species` æ—¶ï¼Œç¼–è¯‘å™¨å‘ç° `Human` ç±»ä¸­æ²¡æœ‰ `species` æˆå‘˜ï¼Œäºæ˜¯ä¼šè‡ªåŠ¨åœ¨ä½œç”¨åŸŸä¸­æŸ¥æ‰¾ä¸€ä¸ªèƒ½æŠŠ `Human` è½¬æˆæœ‰ `species` æˆå‘˜çš„ç±»å‹çš„éšå¼å‡½æ•°ã€‚
 æ­¤æ—¶æ‰¾åˆ°äº† `human2animal`ï¼Œäºæ˜¯ç¼–è¯‘å™¨**è‡ªåŠ¨è°ƒç”¨**å®ƒï¼Œå°† `me` è½¬æˆ `Animal`ï¼Œå†è®¿é—® `species`ã€‚

æ‰€ä»¥è™½ç„¶ä»£ç é‡Œæ²¡æ˜¾å¼è°ƒç”¨ `human2animal`ï¼Œä½†ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸå·²ç»å¸®ä½ åŠ ä¸Šäº†ï¼š

```scala
println(human2animal(me).species)
```

==Case Class:==

`case class` æ›´åƒâ€œæ•°æ®ç±»â€ï¼Œæ–¹ä¾¿å­˜å‚¨ã€æ¯”è¾ƒã€æ‰“å°ï¼›
 `class` æ›´çµæ´»ï¼Œä½†è¦æ‰‹åŠ¨å®ç°è¿™äº›åŠŸèƒ½

```scala
// âœ… case class ç‰ˆæœ¬
case class BinaryMealyParams(
  nStates: Int,
  s0: Int,
  stateTransition: (Int, Boolean) => Int,	//åªç»™å‡ºäº†å‡½æ•°å£°æ˜
  output: (Int, Boolean) => Int
) {
  require(nStates >= 0)
  require(s0 < nStates && s0 >= 0)
}

// âš™ï¸ æ™®é€š class ç‰ˆæœ¬
class BinaryMealyParams(
  val nStates: Int,
  val s0: Int,
  val stateTransition: (Int, Boolean) => Int,
  val output: (Int, Boolean) => Int
) {
  require(nStates >= 0)
  require(s0 < nStates && s0 >= 0)
}
```

åˆ›å»ºcase classç±»ï¼š

```scala
val nStates = 3
val s0 = 2
def stateTransition(state: Int, in: Boolean): Int = {	//å‰é¢åªç»™å‡ºäº†å£°æ˜ï¼Œè¦è¡¥ä¸Šå®šä¹‰
  if (in) {
    1
  } else {
    0
  }
}
def output(state: Int, in: Boolean): Int = {
  if (state == 2) {
    return 0
  }
  if ((state == 1 && !in) || (state == 0 && in)) {
    return 1
  } else {
    return 0
  }
}

val testParams = BinaryMealyParams(nStates, s0, stateTransition, output)	//ä¸ç”¨å†™newäº†
```

==Vecï¼š==

**Vec = å¤šä¸ªç¡¬ä»¶å¯„å­˜å™¨æˆ–çº¿çš„é›†åˆï¼Œæ”¯æŒç´¢å¼•è®¿é—®**

è¿™æ®µä»£ç éœ€è¦ä¸€ç»„å¯„å­˜å™¨æ¥å­˜å†å²æ•°æ®ï¼ˆdelay lineï¼‰ï¼š

```scala
val regs = RegInit(VecInit(...))
```

å¦‚æœä¸ç”¨ `Vec`ï¼Œä½ å¿…é¡»å†™ï¼š

```scala
val reg0 = Reg(...)
val reg1 = Reg(...)
val reg2 = Reg(...)
...
```

å¹¶ä¸”è®¿é—®å›°éš¾ï¼Œæ— æ³•é€šè¿‡ `for(i <- 0 until length)` ç”Ÿæˆé€»è¾‘ã€‚
 ç”¨ `Vec` å¯è®©å¯„å­˜å™¨åƒæ•°ç»„ä¸€æ ·å¤„ç†ï¼Œæ›´é€‚åˆå¯å‚æ•°åŒ–ç”Ÿæˆã€‚

```scala
class MyManyDynamicElementVecFir(length: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(8.W))
    val out = Output(UInt(8.W))
    val consts = Input(Vec(length, UInt(8.W)))	//é•¿åº¦ä¸º length çš„ Vecï¼Œå­˜æ¯ä¸ª tap çš„ç³»æ•°ã€‚
  })

  val regs = RegInit(VecInit(Seq.fill(length - 1)(0.U(8.W))))	//å…ˆå…¨éƒ¨åˆå§‹åŒ–ä¸º0
  for(i <- 0 until length - 1) {
      if(i == 0) regs(i) := io.in
      else       regs(i) := regs(i - 1)
  }
  
  val muls = Wire(Vec(length, UInt(8.W)))
  for(i <- 0 until length) {
      if(i == 0) muls(i) := io.in * io.consts(i)
      else       muls(i) := regs(i - 1) * io.consts(i)
  }

  val scan = Wire(Vec(length, UInt(8.W)))
  for(i <- 0 until length) {
      if(i == 0) scan(i) := muls(i)
      else scan(i) := muls(i) + scan(i - 1)
  }

  io.out := scan(length - 1)
}
```

æµ‹è¯•ï¼š

```scala
val goldenModel = new ScalaFirFilter(Seq(1, 1, 1, 1))

test(new MyManyDynamicElementVecFir(4)) { c =>
    c.io.consts(0).poke(1.U)	//å¯ä»¥åœ¨è¿™é‡Œç»™å†…éƒ¨çš„Vecåƒæ•°ç»„ä¸€æ ·èµ‹å€¼
    c.io.consts(1).poke(1.U)
    c.io.consts(2).poke(1.U)
    c.io.consts(3).poke(1.U)
    for(i <- 0 until 100) {
        val input = scala.util.Random.nextInt(8)

        val goldenModelResult = goldenModel.poke(input)

        c.io.in.poke(input.U)

        c.io.out.expect(goldenModelResult.U, s"i $i, input $input, gm $goldenModelResult, ${c.io.out.peek().litValue}")

        c.clock.step(1)
    }
}
```

**ç”¨ Vec åˆ›å»ºæŸ¥æ‰¾è¡¨ï¼š**

```scala
class RegisterFile(readPorts: Int) extends Module {
    require(readPorts >= 0)
    val io = IO(new Bundle {
        val wen   = Input(Bool())
        val waddr = Input(UInt(5.W))
        val wdata = Input(UInt(32.W))
        val raddr = Input(Vec(readPorts, UInt(5.W)))
        val rdata = Output(Vec(readPorts, UInt(32.W)))
    })
    
    // A Register of a vector of UInts
    val reg = RegInit(VecInit(Seq.fill(32)(0.U(32.W))))
    
    when (io.wen) {
        reg(io.waddr) := io.wdata
    }
    for (i <- 0 until readPorts) {
        when (io.raddr(i) === 0.U) {
            io.rdata(i) := 0.U
        } .otherwise {
            io.rdata(i) := reg(io.raddr(i))	//æ ¹æ®åœ°å€è¯»å–æ•°æ®
        }
    }
}
```

æµ‹è¯•ï¼š

```scala
test(new RegisterFile(2) ) { c =>
  def readExpect(addr: Int, value: Int, port: Int = 0): Unit = {
    c.io.raddr(port).poke(addr.U)
    c.io.rdata(port).expect(value.U)
  }
  def write(addr: Int, value: Int): Unit = {
    c.io.wen.poke(true.B)
    c.io.wdata.poke(value.U)
    c.io.waddr.poke(addr.U)
    c.clock.step(1)
    c.io.wen.poke(false.B)
  }
  // everything should be 0 on init
  for (i <- 0 until 32) {
    readExpect(i, 0, port = 0)
    readExpect(i, 0, port = 1)
  }

  // write 5 * addr + 3
  for (i <- 0 until 32) {
    write(i, 5 * i + 3)
  }

  // check that the writes worked
  for (i <- 0 until 32) {
    readExpect(i, if (i == 0) 0 else 5 * i + 3, port = i % 2)
  }
}
```

==ä»²è£å™¨Arbiter:==

```scala
test(new Module {
    val io = IO(new Bundle {
      val in = Flipped(Vec(2, Decoupled(UInt(8.W))))	// ä¸¤ä¸ªDecoupledçš„è¾“å…¥ä¿¡å·ï¼ˆè¾“å…¥ä¿¡å·è¦ç¿»è½¬ï¼‰
      val out = Decoupled(UInt(8.W))
    })

    val arbiter = Module(new Arbiter(UInt(8.W), 2))  // ä¸¤ä¸ªè¾“å…¥ï¼Œä¸€è·¯è¾“å‡ºçš„ä¼˜å…ˆçº§ä»²è£å™¨
    arbiter.io.in <> io.in
    io.out <> arbiter.io.out
  }) { c =>
    c.io.in(0).valid.poke(false.B)	//è¾“å…¥ä¿¡å·validå’Œbitsä¸ºè¾“å…¥
    c.io.in(1).valid.poke(false.B)
    c.io.out.ready.poke(false.B)	//è¾“å‡ºä¿¡å·readyä¸ºè¾“å…¥
  
    c.io.in(1).valid.poke(true.B)  // Valid input 1
    c.io.in(1).bits.poke(42.U)
    c.io.out.ready.poke(true.B)
   
    c.io.in(0).valid.poke(true.B)  // Valid inputs 0 and 1
    c.io.in(0).bits.poke(43.U)
    
    c.io.in(1).valid.poke(false.B)  // Valid input 0
}
```

è¾“å‡ºï¼š

```scala
Start:
	in(0).ready=0, in(1).ready=0
	out.valid=0, out.bits=0
valid input 1:
	in(0).ready=1, in(1).ready=1
	out.valid=1, out.bits=42
valid inputs 0 and 1:	//å½“ä¸¤ä¸ªä¿¡å·åŒæ—¶æœ‰æ•ˆçš„æ—¶å€™ï¼Œä»²è£å™¨ä¼˜å…ˆé€‰æ‹©ä½çš„In0
	in(0).ready=1, in(1).ready=0
	out.valid=1, out.bits=43
valid input 0:
	in(0).ready=1, in(1).ready=0
	out.valid=1, out.bits=4
```

==PopCountï¼š==

è¿”å›è¾“å…¥ä¸­â€1â€œçš„ä¸ªæ•°

```scala
test(new Module {
    // Example circuit using PopCount
    val io = IO(new Bundle {
      val in = Input(UInt(8.W))
      val out = Output(UInt(8.W))
    })
    io.out := PopCount(io.in)
  }) { c =>
    c.io.in.poke(Integer.parseInt("00000000", 2).U)	//Integer.parseIntç”¨æ¥åˆ›å»ºäºŒè¿›åˆ¶æ•´æ•°
	println(s"in=0b${c.io.in.peek().litValue.toInt.toBinaryString}, out=${c.io.out.peek().litValue}")
    
    c.io.in.poke(Integer.parseInt("00001111", 2).U)
    c.io.in.poke(Integer.parseInt("11001010", 2).U)
    c.io.in.poke(Integer.parseInt("11111111", 2).U)
}
```

è¾“å‡ºï¼š

```scala
in=0b0, out=0
in=0b1111, out=4
in=0b11001010, out=4
in=0b11111111, out=8
```

==Reverseï¼š==

ç¿»è½¬è¾“å…¥

```scala
test(new Module {
    // Example circuit using Reverse
    val io = IO(new Bundle {
      val in = Input(UInt(8.W))
      val out = Output(UInt(8.W))
    })
    io.out := Reverse(io.in)
  }) { c =>
    c.io.in.poke(Integer.parseInt("01010101", 2).U)
    println(s"in=0b${c.io.in.peek().litValue.toInt.toBinaryString}, out=0b${c.io.out.peek().litValue.toInt.toBinaryString}")

    c.io.in.poke(Integer.parseInt("00001111", 2).U)
    c.io.in.poke(Integer.parseInt("11110000", 2).U)
    c.io.in.poke(Integer.parseInt("11001010", 2).U)
}
```

è¾“å‡ºï¼š

```scala
in=0b1010101, out=0b10101010
in=0b1111, out=0b11110000
in=0b11110000, out=0b1111
in=0b11001010, out=0b1010011
```

==OneHotï¼š==

åˆ›å»ºä¸€ä¸ªä»…æœ‰æœ€é«˜ä½ä¸º1çš„äºŒè¿›åˆ¶å€¼(**UIntToOH**)

```scala
test(new Module {
    val io = IO(new Bundle {
      val in = Input(UInt(4.W))
      val out = Output(UInt(16.W))
    })
    io.out := UIntToOH(io.in)
  }) { c =>
    c.io.in.poke(0.U)	//ç¬¬0ä½ä¸º1
    println(s"in=${c.io.in.peek().litValue}, out=0b${c.io.out.peek().litValue.toInt.toBinaryString}")

    c.io.in.poke(1.U)
    c.io.in.poke(8.U)
    c.io.in.poke(15.U)
}
```

è¾“å‡ºï¼š

```scala
in=0, out=0b1
in=1, out=0b10
in=8, out=0b100000000
in=15, out=0b1000000000000000
```

ç»™å‡ºæœ€é«˜ä½1çš„æ‰€åœ¨ä½ç½®ï¼ˆ**OHToUInt**)

```scala
test(new Module {
    val io = IO(new Bundle {
      val in = Input(UInt(16.W))
      val out = Output(UInt(4.W))
    })
    io.out := OHToUInt(io.in)
}) { c =>
    c.io.in.poke(Integer.parseInt("0000 0000 0000 0001".replace(" ", ""), 2).U)
    println(s"in=0b${c.io.in.peek().litValue.toInt.toBinaryString}, out=${c.io.out.peek().litValue}")

    c.io.in.poke(Integer.parseInt("0000 0000 1000 0000".replace(" ", ""), 2).U)
    c.io.in.poke(Integer.parseInt("1000 0000 0000 0001".replace(" ", ""), 2).U)
    c.io.in.poke(Integer.parseInt("0000 0000 0000 0000".replace(" ", ""), 2).U)
    c.io.in.poke(Integer.parseInt("0001 0100 0010 0000".replace(" ", ""), 2).U)
}
```

è¾“å‡ºï¼š

```scala
in=0b1, out=0
in=0b10000000, out=7
in=0b1000000000000001, out=15
in=0b0, out=0	//æ²¡æœ‰1çš„æ—¶å€™ç»“æœä¹Ÿæ˜¯0
in=0b1010000100000, out=15
```

==PriorityMux==

åŒæ—¶é€‰æ‹©æ—¶ä¼˜å…ˆé€‰æ‹©å°ç«¯ä¿¡å·ï¼ˆlowest-index)

```scala
test(new Module {
    val io = IO(new Bundle {
      val in_sels = Input(Vec(2, Bool()))
      val in_bits = Input(Vec(2, UInt(8.W)))
      val out = Output(UInt(8.W))
    })
    io.out := PriorityMux(io.in_sels, io.in_bits)
  }) { c =>
    c.io.in_bits(0).poke(10.U)
    c.io.in_bits(1).poke(20.U)

    // Select higher index only
    c.io.in_sels(0).poke(false.B)	//è¾“å‡º20
    c.io.in_sels(1).poke(true.B)

    // Select both - arbitration needed
    c.io.in_sels(0).poke(true.B)
    c.io.in_sels(1).poke(true.B)	//è¾“å‡º10
}
```

==Mux1H==

-   `Mux1H(sel, data)` çš„å®šä¹‰æ˜¯ **â€œæŒ‰ one-hot é€‰æ‹©è¾“å…¥å¹¶è¿”å›åŠ æƒå’Œâ€**ï¼š

$$
\text{Mux1H(sel, data)} = \sum_i (sel(i) \&\& data(i))
$$

-   å½“ **sel æœ‰å¤šä¸ª 1 æ—¶**ï¼Œå®ƒä¼šæŠŠå¯¹åº”çš„ `data(i)` å…¨éƒ¨ç´¯åŠ ï¼Œè€Œä¸æ˜¯æŠ¥é”™ã€‚

```scala
test(new Module {
    // Example circuit using Mux1H
    val io = IO(new Bundle {
      val in_sels = Input(Vec(2, Bool()))
      val in_bits = Input(Vec(2, UInt(8.W)))
      val out = Output(UInt(8.W))
    })
    io.out := Mux1H(io.in_sels, io.in_bits)
  }) { c =>
    c.io.in_bits(0).poke(10.U)
    c.io.in_bits(1).poke(20.U)

    // Select none (invalid)
    c.io.in_sels(0).poke(false.B)	//è¾“å‡º0
    c.io.in_sels(1).poke(false.B)	
    println(s"in_sels=${c.io.in_sels(0).peek().litValue}, out=${c.io.out.peek().litValue}")

    // Select both (invalid)
    c.io.in_sels(0).poke(true.B)	//è¾“å‡º10+20=30
    c.io.in_sels(1).poke(true.B)
}
```

==Counter==

```scala
test(new Module {
    val io = IO(new Bundle {
      val count = Input(Bool())
      val out = Output(UInt(2.W))
    })
    val counter = Counter(3)  // 3-count Counter (outputs range [0...2])
    when(io.count) {
      counter.inc()	//è‡ªå¢å‡½æ•°è°ƒç”¨
    }
    io.out := counter.value
  }) { c =>
    c.io.count.poke(true.B)
    println(s"start: counter value=${c.io.out.peek().litValue}")

    c.clock.step(1)
    println(s"step 1: counter value=${c.io.out.peek().litValue}")

    c.clock.step(1)
    println(s"step 2: counter value=${c.io.out.peek().litValue}")

    c.io.count.poke(false.B)
    c.clock.step(1)
    println(s"step without increment: counter value=${c.io.out.peek().litValue}")

    c.io.count.poke(true.B)
    c.clock.step(1)
    println(s"step again: counter value=${c.io.out.peek().litValue}")
}
```

è¾“å‡ºï¼š

```scala
start: counter value=0
step 1: counter value=1
step 2: counter value=2
step without increment: counter value=2
step again: counter value=0
```

==é«˜é˜¶å‡½æ•°ï¼šæ¥å—å‡½æ•°ä½œä¸ºå‚æ•°==

æ¯”å¦‚ä¹‹å‰çš„æ»¤æ³¢å™¨ï¼Œå¦‚æœç”¨æ­£å¸¸é€’æ¨æ–¹å¼å†™çš„è¯ï¼š

```scala
val muls = Wire(Vec(length, UInt(8.W)))
for(i <- 0 until length) {
  if(i == 0) muls(i) := io.in * io.consts(i)
  else       muls(i) := regs(i - 1) * io.consts(i)
}

val scan = Wire(Vec(length, UInt(8.W)))
for(i <- 0 until length) {
  if(i == 0) scan(i) := muls(i)
  else scan(i) := muls(i) + scan(i - 1)
}

io.out := scan(length - 1)
```

ä½†æ˜¯å¦‚æœç”¨é«˜é˜¶å‡½æ•°çš„è¯ä»…ä»…éœ€è¦ä¸€è¡Œï¼š

```scala
io.out := (taps zip io.consts).map { case (a, b) => a * b }.reduce(_ + _)
```

`(taps zip io.consts)`ï¼š`zip` æ“ä½œå°†ä¸¤ä¸ªé›†åˆ `taps` å’Œ `io.consts` å¯¹åº”å…ƒç´ ä¸€ä¸€é…å¯¹ï¼Œç”Ÿæˆä¸€ä¸ªç”±å…ƒç»„ `(a, b)` ç»„æˆçš„é›†åˆï¼Œå…¶ä¸­ `a` æ˜¯æ¥è‡ª `taps` çš„å…ƒç´ ï¼Œ`b` æ˜¯æ¥è‡ª `io.consts` çš„å…ƒç´ ã€‚

`.map { case (a, b) => a * b }`ï¼š**ï¼ˆå°†ä¹˜æ³•å‡½æ•°ä½œä¸ºå‚æ•°ï¼‰**è¿™ä¸€æ­¥æ˜¯å¯¹ `zip` åå¾—åˆ°çš„æ¯ä¸ªå…ƒç»„ `(a, b)` è¿›è¡Œæ˜ å°„æ“ä½œï¼Œè®¡ç®—æ¯ä¸€å¯¹å…ƒç´ çš„ä¹˜ç§¯ï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„é›†åˆã€‚

`.reduce(_ + _)`ï¼š**ï¼ˆå°†åŠ æ³•ä½œä¸ºå‚æ•°ï¼‰**æœ€åï¼Œä½¿ç”¨ `reduce` å¯¹æ‰€æœ‰ä¹˜ç§¯è¿›è¡Œç´¯åŠ ï¼Œ`_ + _` è¡¨ç¤ºç´¯åŠ æ“ä½œï¼Œå³å°†é›†åˆä¸­çš„æ‰€æœ‰å…ƒç´ åŠ èµ·æ¥ã€‚

**ä½¿ç”¨ `_` ä½œä¸ºå‚æ•°å ä½ç¬¦ï¼š**

-   åœ¨ Scala ä¸­ï¼Œå½“å‡½æ•°çš„æ¯ä¸ªå‚æ•°åªä½¿ç”¨ä¸€æ¬¡æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹åˆ’çº¿ (`_`) æ¥ä»£æ›¿è¿™äº›å‚æ•°ã€‚è¿™æ˜¯ Scala çš„ç®€å†™è¯­æ³•ã€‚
-   ä¾‹å¦‚ï¼Œ`reduce(_ + _)` è¿™ä¸€å†™æ³•ä¸­ï¼Œä¸¤ä¸ª `_` ä»£è¡¨äº† `reduce` å‡½æ•°çš„ä¸¤ä¸ªå‚æ•°ï¼Œæ„æ€æ˜¯â€œå°†è¿™ä¸¤ä¸ªå…ƒç´ åŠ èµ·æ¥â€ã€‚è¿™ä¸ªç®€å†™å½¢å¼åœ¨ä»£ç ä¸­æé«˜äº†ç®€æ´æ€§ã€‚

**å½“ `_` æ— æ³•æ­£å¸¸å·¥ä½œæ—¶ï¼š**

-   å¦‚æœä½¿ç”¨ `_` æ— æ³•æ­£å¸¸å·¥ä½œæˆ–äº§ç”Ÿé”™è¯¯ï¼Œè§£é‡Šå»ºè®®ä½ æ˜ç¡®æŒ‡å®šå‚æ•°åˆ—è¡¨ã€‚
-   æ¯”å¦‚ï¼Œ`reduce(_ + _)` å¯ä»¥æ˜¾å¼å†™æˆ `(a, b) => a + b`ï¼Œå…¶ä¸­ `(a, b)` æ˜¯æ˜ç¡®çš„å‚æ•°åˆ—è¡¨ï¼Œ`a + b` åˆ™æ˜¯å‡½æ•°ä½“ã€‚è¿™æ ·å†™èƒ½æé«˜ä»£ç çš„å¯è¯»æ€§ã€‚

**ä½¿ç”¨ `case` è§£åŒ…å…ƒç»„ï¼š**

-   æœ‰æ—¶ï¼Œå‡½æ•°çš„å‚æ•°å¯èƒ½æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œä¹Ÿå°±æ˜¯åŒ…å«å¤šä¸ªå…ƒç´ çš„ç»„åˆã€‚ä¾‹å¦‚ï¼Œä½ çš„å‡½æ•°å¯èƒ½éœ€è¦åŒæ—¶æ“ä½œä¸¤ä¸ªå€¼ï¼ˆä¸€ä¸ªå…ƒç»„ `(a, b)`ï¼‰ï¼Œè¿™æ—¶å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…ï¼ˆ`case`ï¼‰æ¥å°†å…ƒç»„ä¸­çš„å…ƒç´ è§£åŒ…æˆå•ç‹¬çš„å˜é‡ã€‚
-   æ¯”å¦‚ï¼Œ`case (a, b) => a * b` å°±æ˜¯åœ¨å¤„ç†ä¸€ä¸ªå…ƒç»„ `(a, b)`ï¼Œå®ƒä¼šè‡ªåŠ¨å°†å…ƒç»„ä¸­çš„ä¸¤ä¸ªå…ƒç´ è§£åŒ…æˆå˜é‡ `a` å’Œ `b`ï¼Œç„¶åè¿›è¡Œç›¸åº”çš„è¿ç®—ã€‚

==Map==

```scala
println(List(1, 2, 3, 4).map(x => x + 1))  // æ˜¾ç¤ºå£°æ˜
println(List(1, 2, 3, 4).map(_ + 1))  // éšå¼å£°æ˜
println(List(1, 2, 3, 4).map(_.toString + "a"))  // å¯ä»¥è½¬æ¢è¾“å‡ºç±»å‹

println(List((1, 5), (2, 6), (3, 7), (4, 8)).map { case (x, y) => x*y })  // è§£å¼€å…ƒç»„è·å¾—å†…éƒ¨å…ƒç´ ï¼Œéœ€è¦ä½¿ç”¨{}

val myList = List("a", "b", "c", "d")
println((0 until 4).map(myList(_)))	// æ‰“å°æ¯ä¸ªListå†…éƒ¨å…ƒç´ 
```

è¾“å‡ºï¼š

```
List(2, 3, 4, 5)
List(2, 3, 4, 5)
List(1a, 2a, 3a, 4a)
List(5, 12, 21, 32)
Vector(a, b, c, d)
```

==zipWithIndex==

ä¸éœ€è¦å‚æ•°ï¼Œä¼šäº§ç”Ÿæ¯ä¸ªå…ƒç´ åŠå…¶å¯¹åº”ä½ç½®çš„å…ƒç»„

```scala
println(List(1, 2, 3, 4).zipWithIndex)  // note indices start at zero
println(List("a", "b", "c", "d").zipWithIndex)
println(List(("a", "b"), ("c", "d"), ("e", "f"), ("g", "h")).zipWithIndex)  // ä¹Ÿå¯ä»¥ç»„åˆä½œä¸º1ä¸ªå…ƒç´ 
```

è¾“å‡ºï¼š

```
List((1,0), (2,1), (3,2), (4,3))
List((a,0), (b,1), (c,2), (d,3))
List(((a,b),0), ((c,d),1), ((e,f),2), ((g,h),3))
```

==reduce==

ç´¯ç§¯æ“ä½œ

```scala
println(List(1, 2, 3, 4).reduce((a, b) => a + b))  // returns the sum of all the elements
println(List(1, 2, 3, 4).reduce(_ * _))  // returns the product of all the elements
println(List(1, 2, 3, 4).map(_ + 1).reduce(_ + _))  // å¯ä»¥åœ¨mapåé¢çº§è”reduce
```

è¾“å‡ºï¼š

```
10
24
14
```

==fold==

ç±»ä¼¼reduceï¼Œä½†æ˜¯å¯ä»¥æŒ‡å®šåˆå§‹ç´¯ç§¯å€¼

```scala
println(List(1, 2, 3, 4).fold(0)(_ + _))  // equivalent to the sum using reduce
println(List(1, 2, 3, 4).fold(1)(_ + _))  // like above, but accumulation starts at 1
println(List().fold(1)(_ + _))  // ä¸åŒäºreduceï¼Œå…è®¸Liståˆ—è¡¨ä¸ºç©ºï¼Œç›´æ¥è¿”å›åˆå§‹å€¼
println(List(1, 2, 3, 4).fold(2)(_ * _))	// 2*(1*2*3*4)
```

è¾“å‡ºï¼š

```
10
11
1
48
```

**æ•´åˆä¾‹å­ï¼š**ä¼˜å…ˆçº§ä»²è£å™¨ï¼ˆPriority Arbiterï¼‰

```scala
class MyRoutingArbiter(numChannels: Int) extends Module {
  val io = IO(new Bundle {
    val in = Vec(numChannels, Flipped(Decoupled(UInt(8.W))))	
    val out = Decoupled(UInt(8.W))
  } )

  io.out.valid := io.in.map(_.valid).reduce(_ || _)		//å°†æ‰€æœ‰è¾“å…¥çš„ valid ä¿¡å·ç”¨é€»è¾‘æˆ–è¿æ¥èµ·æ¥ï¼Œè¡¨ç¤ºåªè¦æœ‰ä»»æ„è¾“å…¥æœ‰æ•ˆï¼Œè¾“å‡ºå°±æœ‰æ•ˆã€‚
  val channel = PriorityMux(
    io.in.map(_.valid).zipWithIndex.map { case (valid, index) => (valid, index.U) }	//æŠŠæ¯ä¸ªè¾“å…¥çš„ valid ä¿¡å·å’Œå®ƒçš„ç´¢å¼•ç»„æˆå…ƒç»„ (valid, index)ï¼ŒåŒæ—¶å°†indexè½¬æ¢ä¸ºUIntç±»å‹
  )
  io.out.bits := io.in(channel).bits	// å°†é€‰ä¸­çš„é€šé“çš„ bits ç›´æ¥ä¼ åˆ°è¾“å‡ºç«¯
  io.in.map(_.ready).zipWithIndex.foreach { case (ready, index) =>	//å¯¹æ¯ä¸ªè¾“å…¥é€šé“ï¼Œè®¾ç½®å®ƒçš„ ready ä¿¡å·
    ready := io.out.ready && channel === index.U	//åªæœ‰å½“è¾“å‡ºç«¯å‡†å¤‡å¥½ (io.out.ready) ä¸”è¯¥é€šé“è¢«é€‰ä¸­ (channel === index.U) æ—¶ï¼Œå¯¹åº”è¾“å…¥æ‰å¯ä»¥è¢«æ¥å—ã€‚
  }
}
```

`io.in.map(_.valid)`ï¼šå–æ¯ä¸ªè¾“å…¥çš„ valid ä¿¡å·ï¼Œ`io.in` æ˜¯ä¸€ä¸ªé•¿åº¦ä¸º `numChannels` çš„ `Vec`ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ `Flipped(Decoupled(UInt(8.W)))`ï¼Œå±äºä¸€ä¸ªåºåˆ—

==Anonymous Functions==

```scala
val myList = List(5, 6, 7, 8)

myList.map( (x:Int) => x + 1 )
myList.map(_ + 1)	//ç­‰æ•ˆäºä¸Šé¢å†™æ³•

// a common situation is to use case statements within an anonymous function
val myAnyList = List(1, 2, "3", 4L, myList)
myAnyList.map {
  case (_:Int|_:Long) => "Number"	//é‡‡ç”¨caseåŠ _æ¥å¿«é€ŸåŒ¹é…ç±»å‹
  case _:String => "String"
  case _ => "error"
}

//æœ€ç»ˆè¾“å‡ºï¼š
List("Number", "Number", "String", "Number", "error")
```



### å®šä¹‰å‡½æ•°

```scala
def hello1(): Unit = print("Hello!")	//è¿”å›ç±»å‹æ˜¯ Unitï¼ŒScala çš„ Unit ç±»ä¼¼äº Java çš„ voidï¼Œæ„å‘³ç€æ²¡æœ‰æœ‰ç”¨çš„è¿”å›å€¼
def hello2 = print("Hello again!")

def times2(x: Int): Int = 2 * x	// æ‰“ä¸ª:è¯´æ˜åé¢è·Ÿçš„ç±»å‹æ˜¯outputçš„ç±»å‹

// è¾“å…¥å¯ä»¥æœ‰é»˜è®¤å€¼
def timesN(x: Int, n: Int = 2) = n * x	// ä¸æ‰“:ç›´æ¥æ¥=è¡¨ç¤ºoutputçš„å€¼

hello1()
hello2
times2(4)
timesN(4)         // no need to specify n to use the default value
timesN(4, 3)      // argument order is the same as the order where the function was defined
timesN(n=7, x=2)  // arguments may be reordered and assigned to explicitly
```

==æ™®é€šå‡½æ•° def å’Œå‡½æ•°å€¼ val==

```scala
def plus1funct(x: Int): Int = x + 1
def times2funct(x: Int): Int = x * 2

val plus1val: Int => Int = x => x + 1	// ç­‰å·ä¸¤è¾¹ä¸€ä¸€å¯¹åº”ï¼Œè¾“å…¥xï¼Œè¾“å‡ºx+1,ç±»å‹éƒ½æ˜¯Int
val times2val = (x: Int) => x * 2

plus1funct(4)
plus1val(4)
plus1funct(x=4)
//plus1val(x=4) // this doesn't work
```

1.  **æ™®é€šå‡½æ•°ï¼ˆ`def`ï¼‰**

-   å®šä¹‰äº†ä¸€ä¸ªæ ‡å‡†å‡½æ•°ï¼Œæœ‰åå­— `plus1funct`ã€‚
-   å¯ä»¥ç”¨**ä½ç½®å‚æ•°**è°ƒç”¨ï¼š`plus1funct(4)`
-   å¯ä»¥ç”¨**å‘½åå‚æ•°**è°ƒç”¨ï¼š`plus1funct(x = 4)`

2.   **å‡½æ•°å€¼ï¼ˆ`val`ï¼‰**

-   å®šä¹‰äº†ä¸€ä¸ªå€¼ `plus1val`ï¼Œå®ƒçš„ç±»å‹æ˜¯å‡½æ•°ç±»å‹ `Int => Int`ã€‚
-   æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼ˆå‡½æ•°å¯¹è±¡ï¼‰ï¼Œå¯ä»¥è°ƒç”¨ï¼š`plus1val(4)`
-   **ä¸èƒ½ä½¿ç”¨å‘½åå‚æ•°**ï¼Œæ‰€ä»¥ `plus1val(x = 4)` ä¸è¡Œã€‚

åŸå› ï¼š

-   **`def` æ˜¯è¯­è¨€çº§åˆ«çš„å‡½æ•°å®šä¹‰**ï¼ŒScala ç¼–è¯‘å™¨å¯ä»¥å¤„ç†å‘½åå‚æ•°ã€é»˜è®¤å‚æ•°ç­‰è¯­æ³•ã€‚
-   **å‡½æ•°å€¼æ˜¯å¯¹è±¡å®ä¾‹**ï¼ˆ`Function1[Int, Int]`ï¼‰ï¼Œè°ƒç”¨å®ƒç›¸å½“äºè°ƒç”¨ `apply` æ–¹æ³•ï¼š`plus1val.apply(4)`ã€‚
-   å¯¹è±¡æ–¹æ³•è°ƒç”¨ä¸æ”¯æŒå‘½åå‚æ•°è¯­æ³•ï¼Œæ‰€ä»¥å‘½åå‚æ•°ä¸ç”Ÿæ•ˆã€‚

==é€šè¿‡å‡½æ•°å€¼ val çš„æ–¹å¼å¯å°†å‡½æ•°ä½œä¸ºå‚æ•°è¿›è¡Œä¼ å‚==

```scala
// create our function
val plus1 = (x: Int) => x + 1
val times2 = (x: Int) => x * 2

val myList = List(1, 2, 5, 9)
val myListPlus = myList.map(plus1)	//å°†å‡½æ•°å€¼valä¼ å‚è¿›å¦ä¸€ä¸ªå‡½æ•°map
val myListTimes = myList.map(times2)

// create a custom function, which performs an operation on X N times using recursion
def opN(x: Int, n: Int, op: Int => Int): Int = {
  if (n <= 0) { x }
  else { opN(op(x), n-1, op) }	//è¿­ä»£
}

opN(7, 3, plus1)	//æˆ–è€…é€šè¿‡å¤šå®šä¹‰ä¸€ä¸ªå‚æ•°çš„æ–¹å¼ç”¨defå®ç°
opN(7, 3, times2)
```

ä¸¤ç§æ–¹å¼åˆå§‹åŒ–æ—¶çš„åŒºåˆ«ï¼š

```scala
import scala.util.Random

// both x and y call the nextInt function, but x is evaluated immediately and y is a function
val x = Random.nextInt
def y = Random.nextInt

// x was previously evaluated, so it is a constant
println(s"x = $x")
println(s"x = $x")

// y is a function and gets reevaluated at each call, thus these produce different results
println(s"y = $y")
println(s"y = $y")
```

è¾“å‡ºï¼š

```
x = 695944669
x = 695944669
y = -1411591560
y = -1451360684
```

**Functionsï¼ˆdefï¼‰**ï¼šæ¯æ¬¡è°ƒç”¨éƒ½ä¼šé‡æ–°æ‰§è¡Œå‡½æ•°ä½“çš„ä»£ç ï¼Œå› æ­¤æ¯æ¬¡è°ƒç”¨éƒ½ä¼šé‡æ–°è®¡ç®—ç»“æœã€‚

**`val`**ï¼šåœ¨å®šä¹‰ï¼ˆå®ä¾‹åŒ–ï¼‰æ—¶å°±å·²ç»æ±‚å€¼å¹¶ä¿å­˜ç»“æœï¼Œä¹‹åå†ä½¿ç”¨è¯¥ `val` æ—¶ä¸ä¼šé‡æ–°è®¡ç®—ï¼Œåªæ˜¯å–å·²ç®—å¥½çš„å€¼ã€‚

==FIRçª—å‡½æ•°ä¾‹å­==

```scala
import scala.math.{abs, round, cos, Pi, pow}

// simple triangular window
val TriangularWindow: (Int, Int) => Seq[Int] = (length, bitwidth) => {	
  val raw_coeffs = (0 until length).map( (x:Int) => 1-abs((x.toDouble-(length-1)/2.0)/((length-1)/2.0)) )
  val scaled_coeffs = raw_coeffs.map( (x: Double) => round(x * pow(2, bitwidth)).toInt)
  scaled_coeffs
}

// Hamming window
val HammingWindow: (Int, Int) => Seq[Int] = (length, bitwidth) => {
  val raw_coeffs = (0 until length).map( (x: Int) => 0.54 - 0.46*cos(2*Pi*x/(length-1)))
  val scaled_coeffs = raw_coeffs.map( (x: Double) => round(x * pow(2, bitwidth)).toInt)
  scaled_coeffs
}

// check it out! first argument is the window length, and second argument is the bitwidth
TriangularWindow(10, 16)
HammingWindow(10, 16)
```

`(Int, Int) => Seq[Int]` è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ª**å‡½æ•°ç±»å‹**ï¼š

-   è¾“å…¥å‚æ•°ï¼šä¸¤ä¸ª `Int`
-   è¿”å›å€¼ç±»å‹ï¼š`Seq[Int]`

```scala
val TriangularWindow: (Int, Int) => Seq[Int] = (length, bitwidth) => { ... }	//ç­‰å·ä¸¤è¾¹ä¸€ä¸€å¯¹åº”
```

æ„æ€æ˜¯ï¼š

-   è¿™æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåå­—å« `TriangularWindow`
-   è¾“å…¥æ˜¯ä¸¤ä¸ªå‚æ•° `length: Int` å’Œ `bitwidth: Int`
-   è¾“å‡ºæ˜¯ `Seq[Int]`ï¼Œé•¿åº¦ä¸º `length` çš„æ•´æ•°åºåˆ—ï¼ˆçª—ç³»æ•°ï¼‰

æŠŠè¿™ä¸ªçª—å‡½æ•°æ•´åˆåˆ° FIR ä¸­ï¼š

```scala
class MyFir(length: Int, bitwidth: Int, window: (Int, Int) => Seq[Int]) extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(bitwidth.W))
    val out = Output(UInt((bitwidth*2+length-1).W)) // expect bit growth, conservative but lazy
  })

  // calculate the coefficients using the provided window function, mapping to UInts
  val coeffs = window(length, bitwidth).map(_.U)
  
  // create an array holding the output of the delays
  // note: we avoid using a Vec here since we don't need dynamic indexing
  val delays = Seq.fill(length)(Wire(UInt(bitwidth.W))).scan(io.in)( (prev: UInt, next: UInt) => {
    next := RegNext(prev)
    next
  })
  
  // multiply, putting result in "mults"
  val mults = delays.zip(coeffs).map{ case(delay: UInt, coeff: UInt) => delay * coeff }
  
  // add up multiplier outputs with bit growth
  val result = mults.reduce(_+&_)

  // connect output
  io.out := result
}

visualize(() => new MyFir(7, 12, TriangularWindow))
```

==ç¥ç»ç½‘ç»œ==

```scala
class Neuron(inputs: Int, act: FixedPoint => FixedPoint) extends Module {
  val io = IO(new Bundle {
    val in      = Input(Vec(inputs, FixedPoint(16.W, 8.BP)))
    val weights = Input(Vec(inputs, FixedPoint(16.W, 8.BP)))
    val out     = Output(FixedPoint(16.W, 8.BP))
  })
  
  val mac = io.in.zip(io.weights).map{ case(a:FixedPoint, b:FixedPoint) => a*b}.reduce(_+_)
  io.out := act(mac)
}
```

`io.in.zip(io.weights)`
 æŠŠä¸¤ä¸ªå‘é‡æŒ‰ç´¢å¼•é…å¯¹ï¼Œä¾‹å¦‚ï¼š
 `Vector(in0,in1,in2)` å’Œ `Vector(w0,w1,w2)` â†’ `Vector((in0,w0), (in1,w1), (in2,w2))`

`.map{ case(a, b) => a * b }`
 å¯¹æ¯ä¸€å¯¹ `(è¾“å…¥, æƒé‡)` åšä¹˜æ³•ï¼Œå¾—åˆ°æ¯ä¸ªä¹˜ç§¯ã€‚

`.reduce(_+_)`
 æŠŠæ‰€æœ‰ä¹˜ç§¯ç›¸åŠ ï¼Œåšç´¯åŠ æ±‚å’Œï¼ˆMACï¼‰

æ¿€æ´»å‡½æ•°ï¼š

![image-20251106165102874](C:\Users\pydu\AppData\Roaming\Typora\typora-user-images\image-20251106165102874.png)

```scala
val Step: FixedPoint => FixedPoint = x => Mux(x <= 0.F(8.BP), 0.F(8.BP), 1.F(8.BP))
val ReLU: FixedPoint => FixedPoint = x => Mux(x <= 0.F(8.BP), 0.F(8.BP), x)
```

`0.F(8.BP)` æ˜¯ Chisel ä¸­ **FixedPoint å­—é¢é‡**çš„å†™æ³•ï¼Œè¡¨ç¤ºä¸€ä¸ªå®šç‚¹æ•°å¸¸é‡ã€‚

å«ä¹‰æ‹†è§£ï¼š

| éƒ¨åˆ†   | å«ä¹‰                                         |
| ------ | -------------------------------------------- |
| `0`    | æ•°å€¼æ˜¯ 0                                     |
| `.F`   | è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ª **FixedPoint å¸¸é‡**             |
| `8.BP` | å°æ•°ä½ï¼ˆBinary Pointï¼‰ä¸º 8 ä½ï¼Œå³æœ‰ 8 ä½å°æ•° |

æ‰€ä»¥ `0.F(8.BP)` è¡¨ç¤ºä¸€ä¸ª **å®šç‚¹æ ¼å¼ä¸ºï¼š\*.\*ï¼ˆå°æ•° 8 ä½ï¼‰** çš„ 0ã€‚

æµ‹è¯•ï¼š

```scala
test(new Neuron(2, Step)) { c =>
    val inputs = Seq(Seq(-1, -1), Seq(-1, 1), Seq(1, -1), Seq(1, 1))
    val weights = Seq(1.0, 1.0)

    c.reset.poke(true.B)
    c.clock.step(5)
    c.reset.poke(false.B)
    for (i <- inputs) {
        c.io.in(0).poke(i(0).F(8.BP))
        c.io.in(1).poke(i(1).F(8.BP))
        c.io.weights(0).poke(weights(0).F(16.W, 8.BP))
        c.io.weights(1).poke(weights(1).F(16.W, 8.BP))
        c.io.out.expect((if (i(0) + i(1) > 0) 1 else 0).F(16.W, 8.BP))
        c.clock.step(1)
    }
}
```

### é¢å‘å¯¹è±¡

==abstract class==

```scala
abstract class MyAbstractClass {
  def myFunction(i: Int): Int
  val myValue: String
}
class ConcreteClass extends MyAbstractClass {
  def myFunction(i: Int): Int = i + 1
  val myValue = "Hello World!"
}

// val abstractClass = new MyAbstractClass() // Illegal! Cannot instantiate an abstract class
val concreteClass = new ConcreteClass()      // Legal!
```

æŠ½è±¡ç±»ï¼ˆabstract classï¼‰å’Œå…¶ä»–è¯­è¨€é‡Œçš„å®ç°æ–¹å¼ç±»ä¼¼ï¼Œå¯ä»¥åŒ…å«**æœªå®ç°çš„æˆå‘˜**ï¼ˆå¦‚æ–¹æ³•æˆ–å˜é‡ï¼‰ï¼Œè¿™äº›å†…å®¹å¿…é¡»ç”±å­ç±»å»å®ç°ã€‚åŒæ—¶ï¼Œä¸€ä¸ªå¯¹è±¡ï¼ˆç±»ï¼‰**åªèƒ½ç›´æ¥ç»§æ‰¿ä¸€ä¸ªæŠ½è±¡ç±»**ï¼Œä¸èƒ½ç»§æ‰¿å¤šä¸ªæŠ½è±¡ç±»ï¼ˆå•ç»§æ‰¿ï¼‰ã€‚

==trait==

```scala
trait HasFunction {
  def myFunction(i: Int): Int
}
trait HasValue {
  val myValue: String
  val myOtherValue = 100
}
class MyClass extends HasFunction with HasValue {	// ç”¨ with æ¥å®ç°å¤šç»§æ‰¿
  override def myFunction(i: Int): Int = i + 1	// override æŒ‡æ˜æ˜¯åœ¨è¦†ç›–çˆ¶ç±»çš„æˆå‘˜å‡½æ•°
  val myValue = "Hello World!"
}

// val myTraitFunction = new HasFunction() // Illegal! Cannot instantiate a trait
// val myTraitValue = new HasValue()       // Illegal! Cannot instantiate a trait
val myClass = new MyClass()                // Legal!
```

trait å’ŒæŠ½è±¡ç±»ä¸€æ ·ï¼Œå¯ä»¥åŒ…å« **æœªå®ç°çš„æˆå‘˜**ï¼ˆæ–¹æ³•æˆ–å˜é‡ï¼‰ï¼Œç”±å­ç±»å®ç°ã€‚

ä¸åŒç‚¹ï¼š

1.  **å¤šç»§æ‰¿**ï¼šä¸€ä¸ªç±»å¯ä»¥ç»§æ‰¿å¤šä¸ª traitï¼Œè€ŒæŠ½è±¡ç±»åªèƒ½å•ç»§æ‰¿ã€‚
2.  **æ— æ„é€ å‚æ•°**ï¼štrait ä¸èƒ½å®šä¹‰æ„é€ å‚æ•°ï¼Œè€ŒæŠ½è±¡ç±»å¯ä»¥

==object==

```scala
object MyObject {
  def hi: String = "Hello World!"
  def apply(msg: String) = msg
}
println(MyObject.hi)
println(MyObject("This message is important!")) // equivalent to MyObject.apply(msg)
```

Scala æä¾›äº†ä¸€ç§ **å•ä¾‹ç±»ï¼ˆsingleton classï¼‰** çš„è¯­è¨€ç‰¹æ€§ï¼Œå«åš `object`ã€‚

-   ä½ ä¸èƒ½ç”¨ `new` æ¥å®ä¾‹åŒ–ä¸€ä¸ª `object`ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡åå­—è®¿é—®å®ƒçš„æˆå‘˜ã€‚
-   å› æ­¤ï¼Œå®ƒç±»ä¼¼äº Java ä¸­çš„ **é™æ€ç±»æˆ–é™æ€æ–¹æ³•å®¹å™¨**ï¼Œé€‚åˆæ”¾å…±äº«å·¥å…·å‡½æ•°æˆ–å…¨å±€çŠ¶æ€ã€‚

==companion object==

```scala
object Lion {
    def roar(): Unit = println("I'M AN OBJECT!")
}
class Lion {
    def roar(): Unit = println("I'M A CLASS!")
}
new Lion().roar()
Lion.roar()
```

**ä¼´ç”Ÿå¯¹è±¡ï¼ˆcompanion objectï¼‰** çš„æ¦‚å¿µï¼š

-   å½“ä¸€ä¸ª `class` å’Œä¸€ä¸ª `object` **åŒåä¸”åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­**ï¼Œè¿™ä¸ª `object` å°±å« **ä¼´ç”Ÿå¯¹è±¡**ã€‚
-   ä½¿ç”¨ `new`ï¼š`new ClassName` â†’ åˆ›å»ºç±»çš„å®ä¾‹ã€‚
-   ä¸ä½¿ç”¨ `new`ï¼šç›´æ¥å†™ `ClassName` â†’ è®¿é—®ä¼´ç”Ÿå¯¹è±¡ã€‚

```scala
object Animal {
    val defaultName = "Bigfoot"
    private var numberOfAnimals = 0
    def apply(name: String): Animal = {
        numberOfAnimals += 1
        new Animal(name, numberOfAnimals)	//é€šè¿‡åœ¨å‡½æ•°å†…éƒ¨è°ƒç”¨æ¥åˆ›å»ºclasså®ä¾‹
    }
    def apply(): Animal = apply(defaultName)
}
class Animal(name: String, order: Int) {
  def info: String = s"Hi my name is $name, and I'm $order in line!"
}

val bunny = Animal.apply("Hopper") // ä¸éœ€è¦å†å†™new
println(bunny.info)
val cat = Animal("Whiskers")       // ç¼–è¯‘å™¨çœ‹åˆ°æ‹¬å· () æ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨å¯¹è±¡çš„ apply æ–¹æ³•ã€‚
println(cat.info)
val yeti = Animal()                // Calls the Animal factory method
println(yeti.info)
```

==factory method==

**å·¥å‚æ–¹æ³•ï¼ˆFactory Methodï¼‰æ˜¯ä¸€ç§è®¾è®¡æ¨¡å¼ï¼Œç”¨æ¥åˆ›å»ºå¯¹è±¡å®ä¾‹**ï¼Œè€Œä¸æ˜¯ç›´æ¥ç”¨ `new` å»å®ä¾‹åŒ–ç±»ã€‚

ç‰¹ç‚¹å’Œä½œç”¨ï¼š

1.  **å°è£…å®ä¾‹åŒ–é€»è¾‘**
    -   é€šè¿‡ä¸€ä¸ªæ–¹æ³•ï¼ˆé€šå¸¸å« `apply` æˆ– `create`ï¼‰è¿”å›ç±»çš„å®ä¾‹ã€‚
    -   å¯ä»¥åœ¨æ–¹æ³•å†…éƒ¨åšé¢å¤–å¤„ç†ï¼Œæ¯”å¦‚å‚æ•°æ£€æŸ¥ã€è®¡æ•°ã€ç¼“å­˜ã€è¿”å›å­ç±»ç­‰ã€‚
2.  **å¥½å¤„**
    -   é¿å…ç›´æ¥ä½¿ç”¨ `new`ï¼Œç»Ÿä¸€å¯¹è±¡åˆ›å»ºå…¥å£ã€‚
    -   å¯ä»¥åœ¨åˆ›å»ºæ—¶åŠ å…¥é€»è¾‘ï¼ˆåˆå§‹åŒ–ã€ç¼–å·ã€è½¬æ¢ï¼‰ã€‚
    -   æ”¯æŒå¤šç§ä¸åŒçš„åˆ›å»ºæ–¹å¼ï¼ˆé‡è½½æ–¹æ³•ï¼‰ã€‚

åœ¨ä½ å‰é¢çš„ Scala ä¾‹å­é‡Œï¼š

```scala
def apply(name: String): Animal = {
  numberOfAnimals += 1
  new Animal(name, numberOfAnimals)
}

def apply(): Animal = apply(defaultName)
```

-   è¿™ä¸¤ä¸ª `apply` æ–¹æ³•å°±æ˜¯å·¥å‚æ–¹æ³•ã€‚
-   è°ƒç”¨ `Animal("Hopper")` æˆ– `Animal()` æ—¶ï¼Œå°±ä¼šé€šè¿‡å·¥å‚æ–¹æ³•ç”Ÿæˆå®ä¾‹ï¼Œå¹¶è‡ªåŠ¨å¤„ç†ç¼–å·ã€‚

==case class==

```scala
class Nail(length: Int) // Regular class
val nail = new Nail(10) // Requires the `new` keyword
// println(nail.length) // Illegal! Class constructor parameters are not by default externally visible

class Screw(val threadSpace: Int) // By using the `val` keyword, threadSpace is now externally visible
val screw = new Screw(2)          // Requires the `new` keyword
println(screw.threadSpace)

case class Staple(isClosed: Boolean) // Case class constructor parameters are, by default, externally visible
val staple = Staple(false)           // No `new` keyword required
println(staple.isClosed)
```

**case classï¼ˆæ ·ä¾‹ç±»ï¼‰** çš„ç‰¹ç‚¹ï¼š

1.  **ç±»å‚æ•°å¯ä»¥è¢«å¤–éƒ¨è®¿é—®**

    -   æ„é€ å‡½æ•°é‡Œçš„å‚æ•°é»˜è®¤æ˜¯ `val`ï¼Œå¯ä»¥ç›´æ¥è®¿é—®ï¼Œä¸éœ€è¦é¢å¤–çš„ getterã€‚

2.  **å®ä¾‹åŒ–æ—¶ä¸ç”¨ `new`**

    -   ä¾‹å¦‚ `val person = Person("Alice", 25)`ï¼Œç›´æ¥åˆ›å»ºå¯¹è±¡ï¼Œä¸ç”¨ `new Person(...)`ã€‚

3.  **è‡ªåŠ¨ç”Ÿæˆ `unapply` æ–¹æ³•**

    -   ç”¨äºæ¨¡å¼åŒ¹é…ï¼Œå¯ä»¥ç›´æ¥è®¿é—®æ‰€æœ‰å‚æ•°ï¼Œä¾‹å¦‚ï¼š

        ```
        person match {
          case Person(name, age) => println(name, age)
        }
        ```

4.  **ä¸èƒ½è¢«ç»§æ‰¿**

    -   case class é»˜è®¤æ˜¯ `final`ï¼Œä¸èƒ½ä½œä¸ºçˆ¶ç±»è¢«ç»§æ‰¿ã€‚

**Case class å¾ˆé€‚åˆç”¨ä½œå‚æ•°å®¹å™¨**ï¼Œå°¤å…¶æ˜¯å½“ä½ çš„ç”Ÿæˆå™¨ï¼ˆgeneratorï¼‰æœ‰å¾ˆå¤šå‚æ•°æ—¶ã€‚

-   **æ„é€ å‡½æ•°ä½œç”¨**ï¼š
    -   å¯ä»¥åœ¨æ„é€ å‡½æ•°é‡Œ **å®šä¹‰æ´¾ç”Ÿå‚æ•°**ï¼ˆderived parametersï¼‰ï¼Œæ¯”å¦‚æ ¹æ®è¾“å…¥å‚æ•°è®¡ç®—å‡ºé¢å¤–å€¼ã€‚
    -   å¯ä»¥ **éªŒè¯è¾“å…¥**ï¼ˆvalidate inputï¼‰ï¼Œç¡®ä¿å¯¹è±¡è¢«åˆ›å»ºæ—¶å‚æ•°åˆæ³•ã€‚

```scala
case class SomeGeneratorParameters(
    someWidth: Int,
    someOtherWidth: Int = 10,
    pipelineMe: Boolean = false
) {
    require(someWidth >= 0)
    require(someOtherWidth >= 0)
    val totalWidth = someWidth + someOtherWidth
}
```

### ç±»åˆ«

objectsçš„ç±»åˆ«å¯ä»¥é€šè¿‡getClassè·å–

```scala
println(10.getClass)
println(10.0.getClass)
println("ten".getClass)
```

è¾“å‡º

```scala
int
double
class java.lang.String
```

==Scala vs. Chisel Types==

```scala
val a = Wire(UInt(4.W))
a := 0.U
```

is legal because `0.U` is of type `UInt` (a Chisel type), whereas

```scala
val a = Wire(UInt(4.W))
a := 0
```

is illegal because 0 is type `Int` (a Scala type).

This is also true of `Bool`, a Chisel type which is distinct from `Boolean`.

```scala
val bool = Wire(Bool())
val boolean: Boolean = false
// legal
when (bool) { ... }
if (boolean) { ... }
// illegal
if (bool) { ... }
when (boolean) { ... }
```

==ç±»å‹è½¬æ¢==

```scala
val x: UInt = 3.U
try {
  println(x.asInstanceOf[Int])	//å¯ä»¥è½¬æ¢æ—¶
} catch {
  case e: java.lang.ClassCastException => println("As expected, we can't cast UInt to Int")	//å¦åˆ™è¾“å‡º
}

// But we can cast UInt to Data since UInt inherits from Data.
println(x.asInstanceOf[Data])
```

```scala
class TypeConvertDemo extends Module {
    val io = IO(new Bundle {
        val in  = Input(UInt(4.W))
        val out = Output(SInt(4.W))
    })
    io.out := io.in.asTypeOf(io.out)	// asTypeOfç±»å‹è½¬æ¢
}
```

```scala
class ConstantSum(in1: Data, in2: Data) extends Module {
    val io = IO(new Bundle {
        val out = Output(chiselTypeOf(in1)) // ä¼ å…¥çš„æ˜¯ å­—é¢é‡ï¼ˆLiteralï¼‰ï¼ŒChisel åœ¨ç¼–è¯‘æ—¶å·²ç»å†³å®šäº†ç±»å‹ï¼Œå¹¶ä¸” chiselTypeOf(in1) ä¼šç»§æ‰¿ in1 çš„ç±»å‹ä¸ä½å®½ã€‚
    })
    (in1, in2) match {
        case (x: UInt, y: UInt) => io.out := x + y
        case (x: SInt, y: SInt) => io.out := x + y
        case _ => throw new Exception("I give up!")
    }
}
println(getVerilog(dut = new ConstantSum(3.U, 4.U)))
println(getVerilog(dut = new ConstantSum(-3.S, 4.S)))
println(getVerilog(dut = new ConstantSum(3.U, 4.S)))
```

è¾“å‡ºï¼š

```
module ConstantSum(
  input        clock,
  input        reset,
  output [1:0] io_out
);
  assign io_out = 2'h3; // åŸæœ¬è¾“å‡ºä¸º7ï¼Œä½†æ˜¯outç»§æ‰¿äº†in1çš„ä½å®½åªæœ‰2ä½ï¼Œå› æ­¤è¾“å‡ºä¸º3
endmodule

Elaborating design...
Done elaborating.
module ConstantSum(
  input        clock,
  input        reset,
  output [2:0] io_out
);
  assign io_out = 3'sh1; // @[cmd11.sc 7:43]
endmodule

Elaborating design...
[error] 	at ... ()
[error] 	at ammonite.$sess.cmd11$Helper$ConstantSum.<init>(cmd11.sc:8)
[error] 	at ammonite.$sess.cmd11$Helper.$anonfun$res11_3$1(cmd11.sc:13)
[error] 	at ... ()
[error] 	at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
```

